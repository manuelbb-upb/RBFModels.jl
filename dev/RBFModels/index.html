<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Module Description · RBFModels.jl</title><link rel="canonical" href="https://manuelbb-upb.github.io/RBFModels.jl/RBFModels/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">RBFModels.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../README/">Readme</a></li><li class="is-active"><a class="tocitem" href>Module Description</a><ul class="internal"><li><a class="tocitem" href="#Some-Radial-Functions"><span>Some Radial Functions</span></a></li><li><a class="tocitem" href="#Solving-the-Interpolation-System"><span>Solving the Interpolation System</span></a></li><li><a class="tocitem" href="#Derivatives"><span>Derivatives</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Module Description</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Module Description</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/manuelbb-upb/RBFModels.jl/blob/master/src/RBFModels.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><pre><code class="language-julia">export auto_grad, auto_jac, grad, jac</code></pre><p>Dependencies of this module:</p><pre><code class="language-julia">using DynamicPolynomials, StaticPolynomials
using ThreadSafeDicts
using Memoize: @memoize
using StaticArrays

import Flux.Zygote as Zyg
using Flux.Zygote: Buffer, @adjoint</code></pre><h1 id="Radial-Basis-Function-Models"><a class="docs-heading-anchor" href="#Radial-Basis-Function-Models">Radial Basis Function Models</a><a id="Radial-Basis-Function-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Radial-Basis-Function-Models" title="Permalink"></a></h1><p>The sub-module <code>RBFModels</code> provides utilities to work with radial basis function [RBF] models. Given <span>$N$</span> data sites <span>$X = \{ x^1, …, x^N \} ⊂ ℝ^n$</span> and values <span>$Y = \{ y^1, …, y^N \} ⊂ ℝ$</span>, an interpolating RBF model <span>$r\colon ℝ^n → ℝ$</span> has the form</p><p class="math-container">\[r(x) = \sum_{i=1}^N w_i φ( \| x - x^i \|_2 ) + p(x),\]</p><p>where <code>p</code> is a multivariate polynomial. The radial function <span>$φ\colon [0, ∞) \to ℝ$</span> defines the RBF and we can solve for the coefficients <span>$w$</span> by solving the interpolation system</p><p class="math-container">\[r( x^i ) \stackrel{!}= y^i \quad \text{for all }i=1,…,N\]</p><p>The function <span>$k(•) = φ(\|•\|_2)$</span> is radially symmetric around the origin. <span>$k$</span> is called the kernel of an RBF.</p><p>We define an abstract super type for radial functions:</p><pre><code class="language-julia">abstract type RadialFunction &lt;: Function end</code></pre><p>Each Type that inherits from <code>RadialFunction</code> should implement an evaluation method. It takes the radius/distance <span>$ρ = ρ(x) = \| x - x^i \|$</span> from <span>$x$</span> to a specific center <span>$x^i$</span>.</p><pre><code class="language-julia">(φ :: RadialFunction )( ρ :: Real ) :: Real = Nothing;</code></pre><p>From an <code>RadialFunction</code> and a vector we can define a shifted kernel function. We allow evaluation for statically sized vectors, too:</p><pre><code class="language-julia">const StatVec{T} = Union{SVector{I,T}, SizedVector{I,T,V}} where {I,V}
const AnyVec{T} = Union{Vector{T}, StatVec{T}}

struct ShiftedKernel &lt;: Function
    φ :: RadialFunction
    c :: AnyVec
end

norm2( vec ) = sqrt(sum( vec.^2 ))

&quot;Evaluate kernel `k` at `x - k.c`.&quot;
function (k::ShiftedKernel)( x :: AnyVec )
    return k.φ( norm2( x .- k.c ) )
end</code></pre><pre class="documenter-example-output">Main.ex-RBFModels.ShiftedKernel</pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>When we have vector data <span>$Y ⊂ ℝ^k$</span>, e.g. from modelling MIMO functions, then Julia easily allows for multiple columns in the righthand side of the interpolation equation system and we get weight vectors for multiple models, that can be thought of as one vector models <span>$r\colon ℝ^n \to ℝ$</span>.</p></div></div><h2 id="Some-Radial-Functions"><a class="docs-heading-anchor" href="#Some-Radial-Functions">Some Radial Functions</a><a id="Some-Radial-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Some-Radial-Functions" title="Permalink"></a></h2><p>The <strong>Gaussian</strong> is defined by <span>$φ(ρ) = \exp \left( - (αρ)^2 \right)$</span>, where <span>$α$</span> is a shape parameter to fine-tune the function.</p><pre><code class="language-julia">&quot;&quot;&quot;
    Gaussian( α = 1 ) &lt;: RadialFunction

A `RadialFunction` with
```math
    φ(ρ) = \\exp( - (α ρ)^2 ).
```
&quot;&quot;&quot;
struct Gaussian &lt;: RadialFunction
    α :: Real

    Gaussian( α :: Real = 1 ) = begin
        @assert α &gt; 0 &quot;The shape parameter `α` must be positive.&quot;
        return new(α)
    end
end

function ( φ :: Gaussian )( ρ :: Real )
    exp( - (φ.α * ρ)^2 )
end</code></pre><p>The <strong>Multiquadric</strong> is <span>$φ(ρ) = - \sqrt{ 1 + (αρ)^2 }$</span> and also has a positive shape parameter. We can actually generalize it to the following form:</p><pre><code class="language-julia">&quot;&quot;&quot;
    Multiquadric( α = 1, β = 1//2 ) &lt;: RadialFunction

A `RadialFunction` with
```math
    φ(ρ) = (-1)^{ \\lceil β \\rceil } ( 1 + (αρ)^2 )^β
```
&quot;&quot;&quot;
struct Multiquadric &lt;: RadialFunction
    α :: Real   # shape parameter
    β :: Real   # exponent

    Multiquadric(α = 1, β = 1//2 ) = begin
        @assert α &gt; 0 &quot;The shape parameter `α` must be positive.&quot;
        @assert β % 1 != 0 &quot;The exponent must not be an integer.&quot;
        @assert β &gt; 0 &quot;The exponent must be positive.&quot;
        new(α,β)
    end
end

function ( φ :: Multiquadric )( ρ :: Real )
    (-1)^(ceil(Int, φ.β)) * ( 1 + (φ.α * ρ)^2 )^φ.β
end</code></pre><p>Related is the <strong>Inverse Multiquadric</strong> <span>$φ(ρ) = (1+(αρ)^2)^{-β}$</span> is related:</p><pre><code class="language-julia">&quot;&quot;&quot;
    InverseMultiquadric( α = 1, β = 1//2 ) &lt;: RadialFunction

A `RadialFunction` with
```math
    φ(ρ) = ( 1 + (αρ)^2 )^{-β}
```
&quot;&quot;&quot;
struct InverseMultiquadric &lt;: RadialFunction
    α :: Real
    β :: Real

    InverseMultiquadric( α = 1, β = 1//2 ) = begin
        @assert α &gt; 0 &quot;The shape parameter `α` must be positive.&quot;
        @assert β &gt; 0 &quot;The exponent must be positive.&quot;
        new(α, β)
    end
end

function ( φ :: InverseMultiquadric )( ρ :: Real )
   ( 1 + (φ.α * ρ)^2 )^(-φ.β)
end</code></pre><p>The <strong>Cubic</strong> is <span>$φ(ρ) = ρ^3$</span>. It can also be generalized:</p><pre><code class="language-julia">&quot;&quot;&quot;
    Cubic( β = 3 ) &lt;: RadialFunction

A `RadialFunction` with
```math
    φ(ρ) = (-1)^{ \\lceil β \\rceil /2 } ρ^β
```
&quot;&quot;&quot;
struct Cubic &lt;: RadialFunction
    β :: Real

    Cubic( β :: Real = 3 ) = begin
        @assert β &gt; 0 &quot;The exponent `β` must be positive.&quot;
        @assert β % 2 != 0 &quot;The exponent `β` must not be an even number.&quot;
        new(β)
    end
end

function ( φ :: Cubic )( ρ :: Real )
    (-1)^ceil(Int, φ.β/2 ) * ρ^φ.β
end</code></pre><p>The thin plate spline is usually defined via <span>$φ(ρ) = ρ^2 \log( ρ )$</span>. We provide a generalized version, which defaults to <span>$φ(ρ) = - ρ^4 \log( ρ )$</span>.</p><pre><code class="language-julia">&quot;&quot;&quot;
    ThinPlateSpline( k = 2 ) &lt;: RadialFunction

A `RadialFunction` with
```math
    φ(ρ) = (-1)^{k+1} ρ^{2k} \\log(ρ)
```
&quot;&quot;&quot;
struct ThinPlateSpline &lt;: RadialFunction
    k :: Int

    ThinPlateSpline( k :: Real = 2 ) = begin
        @assert k &gt; 0 &amp;&amp; k % 1 == 0 &quot;The parameter `k` must be a positive integer.&quot;
        new( Int(k) )
    end
end

function (φ :: ThinPlateSpline )( ρ :: Real )
    (-1)^(k+1) * ρ^(2*k) * log( ρ )
end</code></pre><h2 id="Solving-the-Interpolation-System"><a class="docs-heading-anchor" href="#Solving-the-Interpolation-System">Solving the Interpolation System</a><a id="Solving-the-Interpolation-System-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-the-Interpolation-System" title="Permalink"></a></h2><h3 id="Polynomial-Tail"><a class="docs-heading-anchor" href="#Polynomial-Tail">Polynomial Tail</a><a id="Polynomial-Tail-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomial-Tail" title="Permalink"></a></h3><p>For the interpolation system to be solvable we have to choose the right polynomial space for <span>$p$</span>. Basically, if the RBF Kernel (or the radial function) is <em>conditionally positive definite</em> of order <span>$D$</span> we have to find a polynomial <span>$p$</span> with <span>$\deg p \ge D-1$</span>.<sup class="footnote-reference"><a id="citeref-wendland" href="#footnote-wendland">[wendland]</a></sup> If the kernel is CPD of order <span>$D=0$</span> we do not have to add an polynomial and can interpolate arbitrary (distinct) data points.</p><pre><code class="language-julia">cpd_order( :: Gaussian ) = 0
cpd_order( φ :: Multiquadric ) = ceil( Int, φ.β )
cpd_order( :: InverseMultiquadric ) = 0
cpd_order( φ :: Cubic ) = ceil( Int, φ.β/2 )
cpd_order( φ :: ThinPlateSpline ) = φ.k + 1</code></pre><pre class="documenter-example-output">cpd_order (generic function with 5 methods)</pre><p>The dimension of <span>$Π_{d}(ℝ^n)$</span>, the space of <span>$n$</span>-variate polynomials of degree at most <span>$d$</span>, is</p><p class="math-container">\[   Q = \binom{n+d}{n}\]</p><p>which equates to <span>$Q = n+1$</span> for linear and <span>$Q = (n+2)(n+1)/2$</span> for quadratic polynomials. <br/>We need <span>$\{p_j\}_{1 \le j \le Q}$</span>, a basis of <span>$Π_d(ℝ^n)$</span>.</p><p>The canonical basis is <span>$x_1^{α_1} x_2^{α_2} … x_n^{α_n}$</span> with <span>$α_i ≥ 0$</span> and <span>$Σ_i α_i ≤ d$</span>. For <span>$\bar{d} \le d$</span> we can recursively get the non-negative integer solutions for <span>$Σ_i α_i = \bar{d}$</span> with the following function:</p><pre><code class="language-julia">@doc &quot;&quot;&quot;
    non_negative_solutions( d :: Int, n :: Int)

Return array of solution vectors ``[x_1, …, x_n]`` to the equation
``x_1 + … + x_n = d``
where the variables are non-negative integers.
&quot;&quot;&quot;
function non_negative_solutions( d :: Int, n :: Int )
    if n == 1
        return d
    else
        solutions = [];
        for i = 0 : d
            # make RHS smaller by and find all solutions of length `n-1`
            # then concatenate with difference `d-i`
            for shorter_solution ∈ non_negative_solutions( i, n - 1)
                push!( solutions, [ d-i ; shorter_solution ] )
            end
        end
        return solutions
    end
end</code></pre><pre class="documenter-example-output">Main.ex-RBFModels.non_negative_solutions</pre><p>We use <code>DynamicPolynomials.jl</code> to generate the Polyomials. Furthermore, we employ Memoization (via <code>Memoize.jl</code> and <code>ThreadSafeDicts</code>) to save the result for successive usage.</p><pre><code class="language-julia">@doc &quot;&quot;&quot;
    canonical_basis( n:: Int, d :: Int )

Return the canonical basis of the space of `n`-variate
polynomials of degree at most `d`.
&quot;&quot;&quot;
@memoize ThreadSafeDict function canonical_basis( n :: Int, d :: Int )
    @polyvar Xvar[1 : n]
    basis = DynamicPolynomials.Polynomial{true,Int}[] # list of basis polynomials
    for d̄ = 0 : d
        for multi_exponent ∈ non_negative_solutions( d̄, n )
            push!( basis, DynamicPolynomials.Polynomial(prod( Xvar .^ multi_exponent ) ))
        end
    end
    return basis
end</code></pre><pre class="documenter-example-output">Main.ex-RBFModels.canonical_basis</pre><h3 id="The-equation-system"><a class="docs-heading-anchor" href="#The-equation-system">The equation system</a><a id="The-equation-system-1"></a><a class="docs-heading-anchor-permalink" href="#The-equation-system" title="Permalink"></a></h3><p>Set <span>$P = [ p_j(x^i) ] ∈ ℝ^{N × Q}$</span> and <span>$Φ = φ(\| x^i - x^j \|)$</span>. In case of interpolation, the linear equation system for the coefficients of <span>$r$</span> is</p><p class="math-container">\[    \begin{bmatrix}
    Φ &amp; P \\
    P^T &amp; 0_{Q × Q}
    \end{bmatrix}
    \begin{bmatrix}
        w \\
        λ
    \end{bmatrix}
    =
    \begin{bmatrix}
    Y
    \\
    0_Q
    \end{bmatrix}.\]</p><p>We want a <code>coefficients</code> function and use the following helpers:</p><pre><code class="language-julia">&quot;Evaluate each function in `funcs` on each number/vector in `func_args`,
so that each column corresponds to a function evaluation.&quot;
function _func_matrix( funcs, func_args )
    # easy way:
    ##[ funcs[j](func_args[i]) for i = eachindex(func_args), j = eachindex(funcs) ]

    # Zygote-compatible
    Φ = Buffer( func_args[1], length(func_args), length(funcs) )
    for (i, func) ∈ enumerate(funcs)
        Φ[:,i] = func.( func_args )
    end
    return copy(Φ)
end</code></pre><pre class="documenter-example-output">Main.ex-RBFModels._func_matrix</pre><p>For now, we use the <code>\</code> operator to solve <code>A * coeff = RHS</code>. Furthermore, we allow for different interpolation <code>sites</code> and RBF centers by allowing for passing <code>kernels</code>.</p><pre><code class="language-julia">@doc &quot;&quot;&quot;
    coefficients(sites, values, centers, rad_funcs, polys )

Return the coefficient matrices `w` and `λ` for an rbf model
``r(x) = Σ_{i=1}^N wᵢ φ(\\|x - x^i\\|) + Σ_{j=1}^M λᵢ pᵢ(x)``,
where ``N`` is the length of `rad_funcs` (and `centers`) and ``M``
is the length of `polys`.

The arguments are
* an array of data sites `sites` with vector entries from ``ℝ^n``.
* an array of data values `values` with vector entries from ``ℝ^k``.
* an array of `ShiftedKernel`s.
* an array `polys` of polynomial basis functions.
&quot;&quot;&quot;
function coefficients(
    sites :: Vector{ST},
    values :: Vector{VT},
    kernels :: AnyVec{ShiftedKernel},
    polys :: Vector{&lt;:DynamicPolynomials.Polynomial}
    ) where {ST,VT}

    n_out = length(values[1])

    # Φ-matrix, N columns =̂ basis funcs, rows =̂ sites
    N = length(kernels);
    Φ = _func_matrix( kernels, sites )

    # P-matrix, N × Q
    Q = length(polys)
    P = _func_matrix( polys, sites )

    # system matrix A
    Z = zeros( eltype(Φ), Q, Q )
    A = [ Φ  P;
          P&#39; Z ];

    # build rhs (in a Zygote friendly way)
    F = Buffer( values[1], length(values), length(values[1]) ) ## vals to matrix, columns =̂ outputs
    for (i, val) ∈ enumerate(values)
        F[i, :] = val
    end
    RHS = [
        copy(F) ;
        zeros( eltype(eltype(values)), Q, size(F,2) )
    ];

    # solve system
    coeff = A \ RHS

    # return w and λ
    if ST &lt;: SVector
        return SMatrix{N,n_out}(coeff[1 : N, :]), SMatrix{Q, n_out}(coeff[N+1 : end, :])
    else
        return coeff[1 : N, :], coeff[N+1 : end, :]
    end
end</code></pre><pre class="documenter-example-output">Main.ex-RBFModels.coefficients</pre><h3 id="The-Model-Data-Type"><a class="docs-heading-anchor" href="#The-Model-Data-Type">The Model Data Type</a><a id="The-Model-Data-Type-1"></a><a class="docs-heading-anchor-permalink" href="#The-Model-Data-Type" title="Permalink"></a></h3><p>The actual model type does <em>not</em> store the coefficients, but rather:</p><ul><li>a <code>RBFOutputSystem</code>s and</li><li>a <code>PolynomialSystem</code> (~ vector of polynomials) with <code>num_outputs</code> entries.</li></ul><pre><code class="language-julia">struct RBFOutputSystem{S}
    kernels :: AnyVec{ShiftedKernel}
    weights :: Union{Matrix, SMatrix, SizedMatrix}

    num_outputs :: Int
    num_centers :: Int
end

const NumberOrVector = Union{&lt;:Real, AnyVec{&lt;:Real}}</code></pre><pre class="documenter-example-output">Union{var&quot;#s517&quot;, Union{Vector{var&quot;#s516&quot;}, Union{StaticArrays.SVector{I, var&quot;#s516&quot;}, StaticArrays.SizedVector{I, var&quot;#s516&quot;, V}} where {I, V}} where var&quot;#s516&quot;&lt;:Real} where var&quot;#s517&quot;&lt;:Real</pre><p>We provide methods to evaluate the RBF part of a model, that can also take the distance vector <span>$ρ(x) = [\| x - x^1 \|, …, \| x - x^N \|]$</span>. This way, we can save evaluations later, when we evaluate and differentiate with the same function. <br/>There are a few helper functions:</p><pre><code class="language-julia">&quot;Return the list of difference vectors ``[x .- x^1, …, x - x^N]`` where ``x^i`` are the kernel centers of `rbf`.&quot;
function _offsets( rbf :: RBFOutputSystem, x :: AnyVec )
    return [ k.c .- x for k ∈ rbf.kernels ]
end

&quot;Return a vector containing the distance of `x` to each kernel center of `RBFOutputSystem`.&quot;
function _distances( rbf ::  RBFOutputSystem, x :: AnyVec )
    return norm2.(_offsets( rbf, x) )
end

&quot;Return the vector [ φ₁(ρ₁) … φₙ(ρₙ) ] = [ k1(x) … kn(x) ]&quot;
function _kernel_vector( rbf :: RBFOutputSystem, ρ :: AnyVec{&lt;:Real} )
    map.( getfield.(rbf.kernels, :φ), ρ)
end

# Define vectorization for a scalar.
Base.vec( x :: Number ) = [x,]</code></pre><p>The final method looks like this:</p><pre><code class="language-julia">&quot;Evaluate (output `ℓ` of) `rbf` by plugging in distance `ρ[i]` in radial function `o.kernels[i].φ`.&quot;
function _eval_rbfs_at_ρ(rbf :: RBFOutputSystem, ρ :: AnyVec{&lt;:Real}, ℓ :: Union{Int,Nothing} = nothing )
    W = isnothing(ℓ) ? rbf.weights : rbf.weights[:, ℓ]
    vec(_kernel_vector(rbf, ρ)&#39;W)
end</code></pre><pre class="documenter-example-output">Main.ex-RBFModels._eval_rbfs_at_ρ</pre><p>Of course, it is easy to evaluate, when only the argument <code>x</code> is provided.</p><pre><code class="language-julia">&quot;Evaluate `rbf :: RBFOutputSystem` at site `x`. A single output can be specified with `ℓ`.&quot;
function ( rbf ::  RBFOutputSystem )( x :: AnyVec, ℓ :: Union{Int,Nothing} )
    ρ = _distances( rbf, x )        # calculate distance vector
    return _eval_rbfs_at_ρ( rbf, ρ, ℓ ) # eval at distances
end</code></pre><pre class="documenter-example-output">Main.ex-RBFModels.RBFOutputSystem</pre><p>These methods are used internally:</p><pre><code class="language-julia"># called by RBFModel{S,true}, vector output
_eval_rbf_sys(  ::Val{true}, rbf :: RBFOutputSystem, x :: AnyVec, ℓ :: Union{Int,Nothing} = nothing ) = rbf(x,ℓ)
# called by RBFModel{S,false}, scalar output
_eval_rbf_sys( ::Val{false}, rbf :: RBFOutputSystem, x :: AnyVec, ℓ :: Union{Int,Nothing} = nothing ) = rbf(x,ℓ)[end]</code></pre><pre class="documenter-example-output">_eval_rbf_sys (generic function with 4 methods)</pre><p>For evaluating polynomials, we build our own <code>PolySystem</code>: It contains a list of StaticPolynomials and a flag indicating a static return type.</p><pre><code class="language-julia">struct PolySystem{S}
    polys :: AnyVec{&lt;:StaticPolynomials.Polynomial}
    num_outputs :: Int

    function PolySystem{S}( polys :: AnyVec, num_outputs ) where S
        @assert length(polys) == num_outputs &quot;Provide as many polynomials as outputs.&quot;
        if S == true &amp;&amp; !( polys isa StatVec )
            polys = SizedVector{num_outputs}(polys)
        end
        return new{S}(polys,num_outputs)
    end
end

function ( poly_sys :: PolySystem)( x :: AnyVec, ℓ :: Nothing )
    [ p(x) for p ∈ poly_sys.polys ]
end
function ( poly_sys :: PolySystem )( x :: AnyVec, ℓ :: Int )
    [ poly_sys.polys[ℓ](x),]
end

# called below, from RBFModel, vector output and scalar output
const NothInt = Union{Nothing, Int}
_eval_poly_sys( ::Val{true}, poly_sys :: PolySystem, x :: AnyVec , ℓ :: NothInt ) = poly_sys( x, ℓ)
_eval_poly_sys( ::Val{false}, poly_sys :: PolySystem, x :: AnyVec, ℓ :: NothInt ) = poly_sys( x, ℓ)[end]</code></pre><pre class="documenter-example-output">_eval_poly_sys (generic function with 2 methods)</pre><p>We now have all ingredients to define the model type. We allow for vector valued data sites and determine multiple outputs if needed.</p><p>First, define some helper functions to redefine the training data internally:</p><pre><code class="language-julia">&quot;Return a list of the elements of type `vec_type` applied to all elements from `list_of_vecs`.&quot;
function convert_list_of_vecs( vec_type :: Type, list_of_vecs :: Vector{&lt;:AnyVec} )
    return vec_type.(list_of_vecs)
end

# allow for providing scalar data
function convert_list_of_vecs( vec_type :: Type, list_of_nums :: Vector{&lt;:Real} )
    return convert_list_of_vecs( vec_type, [ [x,] for x ∈ list_of_nums ] )
end

# do nothing if types alreay match
function convert_list_of_vecs(::Type{F}, list_of_vecs :: Vector{F} ) where F
    return list_of_vecs
end</code></pre><pre class="documenter-example-output">convert_list_of_vecs (generic function with 3 methods)</pre><p>Helpers to create kernel functions. Should return <code>SVector</code> when appropriate.</p><pre><code class="language-julia">function _make_kernels( φ_arr :: Union{RadialFunction, AnyVec{RadialFunction}}, sites :: Vector )
    if φ_arr isa RadialFunction
        φ_arr = [φ_arr for i = 1:length(sites)]
    end
    return [ ShiftedKernel(φ_arr[i], sites[i]) for i = eachindex( φ_arr ) ]
end

&quot;Return array of `ShiftedKernel`s based functions in `φ_arr` with centers from `sites`.&quot;
make_kernels( φ_arr, sites :: Vector{&lt;:Vector} ) = _make_kernels( φ_arr, sites )
make_kernels( φ_arr, sites :: Vector{&lt;:StatVec} ) = SVector{length(sites)}(_make_kernels(φ_arr,sites))</code></pre><pre class="documenter-example-output">make_kernels (generic function with 2 methods)</pre><p>The final model struct then is:</p><pre><code class="language-julia">&quot;&quot;&quot;
    RBFModel{S,V}

* `S` is `true` or `false` and indicates whether static arrays are used or not.
* `V` is `true` if vectors should be returned and `false` if scalars are returned.

Initialize via one of the constructors, e.g.,
    `RBFInterpolationModel( sites, values, φ, poly_deg )`
to obain an interpolating RBF model.

See also [`RBFInterpolationModel`](@ref)
&quot;&quot;&quot;
struct RBFModel{S,V}
    rbf_sys :: RBFOutputSystem{S}
    poly_sys :: PolySystem{S}

    # Information fields
    num_vars :: Int
    num_outputs :: Int
    num_centers :: Int
end

function Base.show( io :: IO, mod :: RBFModel{S,V} ) where {S,V}
    compact = get(io, :compact, false)
    if compact
        print(io, &quot;$(mod.num_vars)D$(mod.num_outputs)D-RBFModel{$(S),$(V)&quot;)
    else
        print(io, &quot;RBFModel\n&quot;)
        if S print(io, &quot;* using StaticArrays\n&quot;) end
        if V
            print(io, &quot;* with vector output\n&quot;)
        else
            print(io, &quot;* with scalar output\n&quot;)
        end
        print(io, &quot;* with $(mod.num_centers) centers\n&quot;)
        print(io, &quot;* mapping from ℝ^$(mod.num_vars) to ℝ^$(mod.num_outputs).&quot;)
    end
end


function (mod :: RBFModel{S,V} )( x :: AnyVec, ℓ :: NothInt = nothing ) where{S,V}
    rbf_eval = _eval_rbf_sys( Val(V), mod.rbf_sys, x, ℓ )
    poly_eval = _eval_poly_sys( Val(V), mod.poly_sys, x, ℓ )

    return rbf_eval .+ poly_eval
end

# scalar input
function (mod :: RBFModel)(x :: Real, ℓ :: NothInt = nothing )
    @assert mod.num_vars == 1 &quot;The model has more than 1 inputs. Provide a vector `x`, not a number.&quot;
    mod( [x,], ℓ)
end</code></pre><p>The <code>RBFInterpolationModel</code> constructor takes data sites and values and return an <code>RBFModel</code> that interpolates these points. We allow for passing scalar data and transform it internally.</p><pre><code class="language-julia">&quot;&quot;&quot;
    RBFInterpolationModel( sites :: Vector{VS}, values :: Vector{VT}, φ, poly_deg = 1;
        static_arrays = nothing, vector_output = true ) where {VS&lt;:NumberOrVector, VT&lt;:NumberOrVector}

Return an RBFModel `m` that is interpolating, i.e., `m(sites[i]) == values[i]` for all
`i = eachindex(sites)`.
`φ` should be a `RadialFunction` or a vector of `RadialFunction`s that has the same length
as `sites` and `values`.
`poly_deg` specifies the degree of the multivariate polynomial added to the RBF model.
It will be reset if needed.
`static_arrays` is automatically set to `true` if unspecified and the data dimensions are small.
`vector_output` is ignored if the `values` have length &gt; 1. Elsewise it specifies whether to return
vectors or scalars when evaluating.
&quot;&quot;&quot;
function RBFInterpolationModel(
    s̃ides :: Vector{ VecTypeS },
    ṽalues :: Vector{ VecTypeV },
    φ :: Union{RadialFunction,Vector{&lt;:RadialFunction}},
    poly_deg :: Int = 1;
    static_arrays :: Union{Bool, Nothing} = nothing,
    vector_output :: Bool = true,
    ) where { VecTypeS&lt;:NumberOrVector, VecTypeV&lt;:NumberOrVector }

    # data integrity checks
    @assert length(s̃ides) == length(ṽalues) &quot;Provide as many data sites as data labels.&quot;
    @assert !isempty(s̃ides) &quot;Provide at least 1 data site.&quot;
    num_vars = length(s̃ides[1])
    num_outputs = length(ṽalues[1])
    @assert all( length(s) == num_vars for s ∈ s̃ides ) &quot;All sites must have same dimension.&quot;
    @assert all( length(v) == num_outputs for v ∈ ṽalues ) &quot;All values must have same dimension.&quot;

    # use static arrays? if no user preference is set …
    if isnothing(static_arrays)
        # … use only if matrices are small
        static_arrays = (num_vars &lt;= 10 &amp;&amp; num_outputs &lt;= 10)
    end

    # prepare provided training data
    # use same precision everywhere ( at least half-precision )
    TypeS = eltype( VecTypeS )
    TypeV = eltype( VecTypeV )
    dtype = promote_type( TypeS, TypeV, Float16 )
    NewVecTypeS = static_arrays ? SVector{ num_vars, dtype } : Vector{dtype}
    NewVecTypeV = static_arrays ? SVector{ num_outputs, dtype } : Vector{dtype}
    sites = convert_list_of_vecs( NewVecTypeS, s̃ides )
    values = convert_list_of_vecs( NewVecTypeV, ṽalues )

    kernels = make_kernels( φ, sites )
    poly_deg = min( poly_deg, cpd_order(φ) - 1 )
    poly_basis = canonical_basis( num_vars, poly_deg )

    w, λ = coefficients( sites, values, kernels, poly_basis )

    # build output polynomials
    poly_vec = StaticPolynomials.Polynomial[]
    for coeff_ℓ ∈ eachcol( λ )
        push!( poly_vec, StaticPolynomials.Polynomial( poly_basis&#39;coeff_ℓ ) )
    end
    poly_sys = PolySystem{static_arrays}( poly_vec, num_outputs )

    # vector output? (dismiss user choice if labels are vectors)
    vec_output = num_outputs == 1 ? vector_output : true

    # build RBF system
    num_centers = length(sites)
    rbf_sys = RBFOutputSystem{static_arrays}(kernels, w, num_outputs, num_centers)

    return RBFModel{static_arrays, vec_output}(
        rbf_sys, poly_sys, num_vars, num_outputs, num_centers
    )
end</code></pre><pre class="documenter-example-output">Main.ex-RBFModels.RBFInterpolationModel</pre><p>We want to provide an alternative constructor for interpolation models so that the radial function can be defined by passing a <code>Symbol</code> or <code>String</code>.</p><pre><code class="language-julia">const SymbolToRadialConstructor = NamedTuple((
    :gaussian =&gt; Gaussian,
    :multiquadric =&gt; Multiquadric,
    :inv_multiquadric =&gt; InverseMultiquadric,
    :cubic =&gt; Cubic,
    :thin_plate_spline =&gt; ThinPlateSpline
))

function RBFInterpolationModel(
        s̃ides :: Vector{ &lt;: NumberOrVector },
        ṽalues :: Vector{ &lt;:NumberOrVector },
        radial_func :: Union{Symbol, String},
        constructor_args :: Union{Nothing, Vector{&lt;:Tuple}, Tuple} = nothing,
        poly_deg :: Int = 1; kwargs ...
    )

    # which radial function to use?
    radial_symb = Symbol( lowercase( string( radial_func ) ) )
    if !(radial_symb ∈ keys(SymbolToRadialConstructor))
        @warn &quot;Radial Funtion $(radial_symb) not known, using Gaussian.&quot;
        radial_symb = :gaussian
    end
    constructor = SymbolToRadialConstructor[radial_symb]

    if isnothing(constructor_args)
        φ = constructor()
    elseif constructor_args isa Tuple
        φ = constructor( constructor_args... )
    elseif constructor_args isa Vector
        @assert length(constructor_args) == length(s̃ides)
        φ = [ constructor( arg_tuple... ) for arg_tuple ∈ constructor_args ]
    end

    return RBFInterpolationModel( s̃ides, ṽalues, φ, poly_deg; kwargs... )

end</code></pre><pre class="documenter-example-output">RBFInterpolationModel (generic function with 5 methods)</pre><h2 id="Derivatives"><a class="docs-heading-anchor" href="#Derivatives">Derivatives</a><a id="Derivatives-1"></a><a class="docs-heading-anchor-permalink" href="#Derivatives" title="Permalink"></a></h2><p>The easiest way to provide derivatives is via Automatic Differentiation. We have imported <code>Flux.Zygote</code> as <code>Zyg.</code> this allows us to define the following methods:</p><ul><li>A function to return the jacobian:</li></ul><pre><code class="language-julia">&quot;Return the jacobian of `rbf` at `x` (using Zygote).&quot;
function auto_jac( rbf :: RBFModel, x :: NumberOrVector )
    Zyg.jacobian( rbf, x )[1]
end</code></pre><pre class="documenter-example-output">Main.ex-RBFModels.auto_jac</pre><ul><li>A function to evaluate the model and return the jacobian at the same time:</li></ul><pre><code class="language-julia">function eval_and_auto_jac( rbf :: RBFModel, x :: NumberOrVector )
    y, back = Zyg._pullback( rbf, x )

    T = eltype(y)
    n = length(y)
    jac = zeros(T, n, length(x) )
    for i = 1 : length(x)
        e = [ zeros(T, i -1 ); T(1); zeros(T, n - i )  ]
        jac[i, :] .= back(e)[2]
    end

    return y, jac
end</code></pre><pre class="documenter-example-output">eval_and_auto_jac (generic function with 1 method)</pre><ul><li>A function to return the gradient of a specific output:</li></ul><pre><code class="language-julia">&quot;Return gradient of output `ℓ` of model `rbf` at point `x` (using Zygote).&quot;
function auto_grad( rbf :: RBFModel, x :: NumberOrVector, ℓ :: Union{Int,Nothing} = nothing)
    Zyg.gradient( χ -&gt; rbf(χ, ℓ)[end], x )[1]
end</code></pre><pre class="documenter-example-output">Main.ex-RBFModels.auto_grad</pre><ul><li>A function to evaluate the function and return the gradient</li></ul><pre><code class="language-julia">function eval_and_auto_grad( rbf :: RBFModel, x :: NumberOrVector, ℓ :: Union{Int,Nothing} = nothing )
    y, back = Zyg._pullback( χ -&gt; rbf(χ, ℓ)[end], x)

    grad = back( one(y) )[2]
    return y, grad
end</code></pre><pre class="documenter-example-output">eval_and_auto_grad (generic function with 2 methods)</pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The above methods will fail, if <code>x</code> is one of the rbf centers.</p></div></div><p>But we don&#39;t need <code>Zygote</code>, because we can derive the gradients ourselves. Assume that <span>$φ$</span> is two times continuously differentiable. <br/>What is the gradient of a scalar RBF model? Using the chain rule and <span>$ξ = x - x^j$</span> we get</p><p class="math-container">\[\dfrac{∂}{∂ξ_i} \left( φ(\| ξ \|) \right)
=
φ\prime ( \| ξ \| ) \cdot
\dfrac{∂}{∂ξ_i} ( \| ξ \| )
=
φ\prime ( \| ξ \| ) \cdot
\dfrac{ξ_i}{\|ξ\|}.\]</p><p>The right term is always bounded, but not well defined for <span>$ξ = 0$</span> (see <sup class="footnote-reference"><a id="citeref-wild_diss" href="#footnote-wild_diss">[wild_diss]</a></sup> for details). <br/><strong>That is why we require <span>$φ&#39;(0) \stackrel{!}= 0$</span>.</strong> <br/>We have <span>$\dfrac{∂}{∂x_i} ξ(x) = 1$</span> and thus</p><p class="math-container">\[∇r(x) = \sum_{i=1}^N \frac{w_i φ\prime( \| x - x^i \| )}{\| x - x^i \|} (x - x^i) + ∇p(x)\]</p><p>Hence, we need the derivatives of our <code>RadialFunctions</code>.</p><pre><code class="language-julia">df(φ :: Gaussian, ρ :: Real) = - 2 * φ.α * φ( ρ )
df(φ :: Multiquadric, ρ :: Real ) = (-1)^(ceil(Int, φ.β)) * 2 * φ.α * φ.β * ρ * ( 1 + (φ.α * ρ)^2 )^(φ.β - 1)
df(φ :: InverseMultiquadric, ρ :: Real ) = - 2 * φ.α^2 * φ.β * ρ * ( 1 + (φ.α * ρ)^2 )^(-φ.β - 1)
df(φ :: Cubic, ρ :: Real ) = (-1)^(ceil(Int, φ.β/2)) * φ.β * ρ^(φ.β - 1)
df(φ :: ThinPlateSpline, ρ :: Real ) = ρ == 0 ? 0 : (-1)^(φ.k+1) * ρ^(2*φ.k - 1) * ( 2 * φ.k * log(ρ) + 1)</code></pre><pre class="documenter-example-output">df (generic function with 5 methods)</pre><p>We can then implement the formula from above. For a fixed center <span>$x^i$</span> let <span>$o$</span> be the distance vector <span>$x - x^i$</span> and let <span>$ρ$</span> be the norm <span>$ρ = \|o\| = \| x- x^i \|$</span>. Then, the gradient of a single kernel is:</p><pre><code class="language-julia">function grad( k :: ShiftedKernel, o :: AnyVec, ρ :: Real )
    ρ == 0 ? zero(k.c) : (df( k.φ, ρ )/ρ) .* o
end</code></pre><pre class="documenter-example-output">grad (generic function with 1 method)</pre><p>In terms of <code>x</code>:</p><pre><code class="language-julia">function grad( k :: ShiftedKernel, x :: NumberOrVector )
    o = x .- k.c    # offset vector
    ρ = norm2( o )  # distance
    return grad( k, o, ρ )
end</code></pre><pre class="documenter-example-output">grad (generic function with 2 methods)</pre><p>Hence the gradients of an RBFOutputSystem are easy:</p><pre><code class="language-julia">function grad( rbf :: RBFOutputSystem, x :: NumberOrVector, ℓ :: Int )
    W = rbf.weights[:, ℓ]   # weights for output ℓ
    return sum( W .* [ grad(k, x ) for k ∈ kernels ] )
end</code></pre><pre class="documenter-example-output">grad (generic function with 3 methods)</pre><p>For the jacobian, we use <code>grad(k, o, ρ)</code> to save evaluations:</p><pre><code class="language-julia">function jac( rbf :: RBFOutputSystem{S}, x :: NumberOrVector ) where S

    T = promote_type( eltype(x), eltype(rbf.weights) )
    J = (S ? MMatrix{rbf.num_outputs, length(x)} : Matrix )( zeros(T, rbf.num_outputs, length(x) ) )

    o = [ x .- k.c for k ∈ rbf.kernels ]    # all offset vectors
    ρ = norm2.(o)       # all distances
    for ℓ = 1 : rbf.num_outputs
        W = rbf.weights[:,ℓ]
        J[ℓ, :] = sum( W .* [ grad( i...) for i ∈ zip( rbf.kernels, o, ρ) ] )
    end
    return J
end</code></pre><pre class="documenter-example-output">jac (generic function with 1 method)</pre><p>For the Hessian <span>$Hr \colon ℝ^n \to ℝ^{n\times n}$</span> we need the gradients of the component functions</p><p class="math-container">\[    ψ_j(ξ) = \frac{ φ&#39;( \left\| ξ \right\| )}{\|ξ\|} ξ_j\]</p><p>Suppose <span>$ξ ≠ 0$</span>. First, using the product rule, we have</p><p class="math-container">\[   \dfrac{∂}{∂ξ_i}
   \left(
   \frac{ φ&#39;( \left\| ξ \right\| )}{\|ξ\|} ξ_j
   \right) =
   ξ_j
   \dfrac{∂}{∂ξ_i}
   \left(
   \frac{ φ&#39;( \left\| ξ \right\| )}{\|ξ\|}
   \right)
   +
   \frac{ φ&#39;( \left\| ξ \right\| )}{\|ξ\|}
   \dfrac{∂}{∂ξ_i}
   ξ_j\]</p><p>The last term is easy because of</p><p class="math-container">\[\frac{∂}{∂ξ_i} ξ_j
=
\begin{cases}
    1 &amp; \text{if }i = j,\\
    0 &amp; \text{else.}
\end{cases}\]</p><p>For the first term we find</p><p class="math-container">\[   \dfrac{∂}{∂ξ_i}
   \left(
     \frac{ φ&#39;( \left\| ξ \right\| )}
      {\|ξ\|}
   \right)
   =
   \frac{
       φ&#39;\left(\left\| ξ \right\|\right) ∂_i \|ξ\|
       - \|ξ\| ∂_i φ&#39;\left( \left\| ξ \right\|\right)
    }{
        \|ξ\|^2
    }
    =
    \frac{
        \dfrac{φ&#39;(\|ξ\|)}{\|ξ\|} ξ_i - \|ξ\|φ&#39;&#39;(\|ξ\|)\dfrac{ξ_i}{\|ξ\|}
    }{\|ξ\|^2}\]</p><p>Hence, the gradient of <span>$ψ_j$</span> is</p><p class="math-container">\[    ∇ψ_j(ξ)
    =
    \left( \frac{φ&#39;(\|ξ\|)}{\|ξ\|^3}
    -
    \frac{φ&#39;&#39;(\|ξ\|)}{\|ξ\|^2} \right) \cdot ξ
    -\frac{φ&#39;(\|ξ\|)}{\|ξ\|} e^j,\]</p><p>where <span>$e^j ∈ ℝ^n$</span> is all zeros, except <span>$e^j_j = 1$</span>. For <span>$ξ = 0$</span> the first term vanishes due to L&#39;Hôpital&#39;s rule:</p><p class="math-container">\[∇ψ_j(0) = φ&#39;&#39;(0) e^j.\]</p><h3 id="Custom-Adjoints"><a class="docs-heading-anchor" href="#Custom-Adjoints">Custom Adjoints</a><a id="Custom-Adjoints-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Adjoints" title="Permalink"></a></h3><p>For automatic differentiation we need custom adjoints for some <code>StaticArrays</code>:</p><pre><code class="language-julia">#@adjoint (T::Type{&lt;:StaticArrays.SizedMatrix})(x::AbstractMatrix) = T(x), dv -&gt; (nothing, dv)
#@adjoint (T::Type{&lt;:StaticArrays.SVector})(x::AbstractVector) = T(x), dv -&gt; (nothing, dv)
#@adjoint (T::Type{&lt;:StaticArrays.SizedVector})(x::AbstractVector) = T(x), dv -&gt; (nothing, dv)</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-wild_diss"><a class="tag is-link" href="#citeref-wild_diss">wild_diss</a>“Derivative-Free Optimization Algorithms For Computationally Expensive Functions”, Wild, 2009.</li><li class="footnote" id="footnote-wendland"><a class="tag is-link" href="#citeref-wendland">wendland</a>“Scattered Data Approximation”, Wendland</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../README/">« Readme</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 10 May 2021 16:19">Monday 10 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
