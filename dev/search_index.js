var documenterSearchIndex = {"docs":
[{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"EditURL = \"https://github.com/manuelbb-upb/RBFModels.jl/blob/master/src/RBFModels.jl\"","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"Dependencies of this module:","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"using DynamicPolynomials, StaticPolynomials\nusing ThreadSafeDicts\nusing Memoize: @memoize\nusing StaticArrays\n\nusing Flux.Zygote: Buffer","category":"page"},{"location":"RBFModels/#Radial-Basis-Function-Models","page":"Module Description","title":"Radial Basis Function Models","text":"","category":"section"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"The sub-module RBFModels provides utilities to work with radial basis function [RBF] models. Given N data sites X =  x^1  x^N   ℝ^n and values Y =  y^1  y^N   ℝ, an interpolating RBF model rcolon ℝ^n  ℝ has the form","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"r(x) = sum_i=1^N w_i φ(  x - x^i _2 ) + p(x)","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"where p is a multivariate polynomial. The radial function φcolon 0 ) to ℝ defines the RBF and we can solve for the coefficients w by solving the interpolation system","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"r( x^i ) stackrel= y^i quad textfor all i=1N","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"The function k() = φ(_2) is radially symmetric around the origin. k is called the kernel of an RBF.","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"We define an abstract super type for radial functions:","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"abstract type RadialFunction <: Function end","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"Each Type that inherits from RadialFunction should implement an evaluation method:","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"(φ :: RadialFunction )( x :: Real ) :: Real = Nothing;\nnothing #hide","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"From an RadialFunction and a vector we can define a shifted kernel function:","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"struct ShiftedKernel <: Function\n    φ :: RadialFunction\n    c :: Union{Vector, SVector}\nend\n\nnorm2( vec ) = sqrt(sum( vec.^2 ))\nfunction (k::ShiftedKernel)( x :: Union{Vector, SVector} )\n    return k.φ( norm2( x .- k.c ) )\nend","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"note: Note\nWhen we have vector data Y  ℝ^k, e.g. from modelling MIMO functions, then Julia easily allows for multiple columns in the righthand side of the interpolation equation system and we get weight vectors for multiple models, that can be thought of as one vector models rcolon ℝ^n to ℝ.","category":"page"},{"location":"RBFModels/#Some-Radial-Functions","page":"Module Description","title":"Some Radial Functions","text":"","category":"section"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"The Gaussian is defined by φ(ρ) = exp left( - (αρ)^2 right), where α is a shape parameter to fine-tune the function.","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"struct Gaussian <: RadialFunction\n    α :: Real\n\n    Gaussian( α :: Real = 1 ) = begin\n        @assert α > 0 \"The shape parameter `α` must be positive.\"\n        return new(α)\n    end\nend\n\nfunction ( φ :: Gaussian )( ρ :: Real )\n    exp( - (φ.α * ρ)^2 )\nend","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"The Multiquadric is φ(ρ) = - sqrt 1 + (αρ)^2  and also has a positive shape parameter. We can actually generalize it to the following form:","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"struct Multiquadric <: RadialFunction\n    α :: Real   # shape parameter\n    β :: Real   # exponent\n\n    Multiquadric(α = 1, β = .5) = begin\n        @assert α > 0 \"The shape parameter `α` must be positive.\"\n        @assert β % 1 != 0 \"The exponent must not be an integer.\"\n        @assert β > 0 \"The exponent must be positive.\"\n        new(α,β)\n    end\nend\n\nfunction ( φ :: Multiquadric )( ρ :: Real )\n    (-1)^(ceil(Int, φ.β)) * ( 1 + (φ.α * ρ)^2 )^φ.β\nend","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"Related is the Inverse Multiquadric φ(ρ) = (1+(αρ)^2)^-β is related:","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"struct InverseMultiquadric <: RadialFunction\n    α :: Real\n    β :: Real\n\n    Multiquadric( α = 1, β = .5 ) = begin\n        @assert α > 0 \"The shape parameter `α` must be positive.\"\n        @assert β > 0 \"The exponent must be positive.\"\n        new(α, β)\n    end\nend\n\nfunction ( φ :: InverseMultiquadric )( ρ :: Real )\n   ( 1 + (φ.α * ρ)^2 )^(-φ.β)\nend","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"The Cubic is φ(ρ) = ρ^3. It can also be generalized:","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"struct Cubic <: RadialFunction\n    β :: Real\n\n    Cubic( β :: Real = 3 ) = begin\n        @assert β > 0 \"The exponent `β` must be positive.\"\n        @assert β % 2 != 0 \"The exponent `β` must not be an even number.\"\n        new(β)\n    end\nend\n\nfunction ( φ :: Cubic )( ρ :: Real )\n    (-1)^ceil(Int, φ.β/2 ) * ρ^φ.β\nend","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"The thin plate spline is usually defined via φ(ρ) = ρ^2 log( ρ ). We provide a generalized version, which defaults to φ(ρ) = - ρ^4 log( ρ ).","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"struct ThinPlateSpline <: RadialFunction\n    k :: Int\n\n    ThinPlateSpline( k :: Real = 2 ) = begin\n        @assert k > 0 && k % 1 == 0 \"The parameter `k` must be a positive integer.\"\n        new( Int(k) )\n    end\nend\n\nfunction (φ :: ThinPlateSpline )( ρ :: Real )\n    (-1)^(k+1) * ρ^(2*k) * log( ρ )\nend","category":"page"},{"location":"RBFModels/#Solving-the-Interpolation-System","page":"Module Description","title":"Solving the Interpolation System","text":"","category":"section"},{"location":"RBFModels/#Polynomial-Tail","page":"Module Description","title":"Polynomial Tail","text":"","category":"section"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"For the interpolation system to be solvable we have to choose the right polynomial space for p. Basically, if the RBF Kernel (or the radial function) is conditionally positive definite of order D we have to find a polynomial p with deg p = D-1.[wendland] If the kernel is CPD of order D=0 we do not have to add an polynomial and can interpolate arbitrary (distinct) data points.","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"cpd_order( :: Gaussian ) = 0\ncpd_order( φ :: Multiquadric ) = ceil( Int, φ.β )\ncpd_order( :: InverseMultiquadric ) = 0\ncpd_order( φ :: Cubic ) = ceil( Int, φ.β/2 )\ncpd_order( φ :: ThinPlateSpline ) = φ.k + 1","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"The dimension of Π_d(ℝ^n), the space of n-variate polynomials of degree at most d, is","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"   Q = binomn+dn","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"which equates to Q = n+1 for linear and Q = (n+2)(n+1)2 for quadratic polynomials. \nWe need p_j_1 le j le Q, a basis of Π_d(ℝ^n).","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"The canonical basis is x_1^α_1 x_2^α_2  x_n^α_n with α_i  0 and Σ_i α_i  d. For bard le d we can recursively get the non-negative integer solutions for Σ_i α_i = bard with the following function:","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"@doc \"\"\"\n    non_negative_solutions( d :: Int, n :: Int)\n\nReturn array of solution vectors [x_1, …, x_n] to the equation\n``x_1 + … + x_n = d``\nwhere the variables are non-negative integers.\n\"\"\"\nfunction non_negative_solutions( d :: Int, n :: Int )\n    if n == 1\n        return d\n    else\n        solutions = [];\n        for i = 0 : d\n            # make RHS smaller by and find all solutions of length `n-1`\n            # then concatenate with difference `d-i`\n            for shorter_solution ∈ non_negative_solutions( i, n - 1)\n                push!( solutions, [ d-i ; shorter_solution ] )\n            end\n        end\n        return solutions\n    end\nend","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"We use DynamicPolynomials.jl to generate the Polyomials. Furthermore, we employ Memoization (via Memoize.jl and ThreadSafeDicts) to save the result for successive usage.","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"@doc \"\"\"\n    canonical_basis( n:: Int, d :: Int )\n\nReturn the canonical basis of the space of `n`-variate\npolynomials of degree at most `d`.\n\"\"\"\n@memoize ThreadSafeDict function canonical_basis( n :: Int, d :: Int )\n    @polyvar Xvar[1 : n]\n    basis = StaticPolynomials.Polynomial[]  # list of basis polynomials\n    for d̄ = 0 : d\n        for multi_exponent ∈ non_negative_solutions( d̄, n )\n            push!( basis, StaticPolynomials.Polynomial( prod( Xvar .^ multi_exponent ) ) )\n        end\n    end\n    return basis\nend","category":"page"},{"location":"RBFModels/#The-equation-system","page":"Module Description","title":"The equation system","text":"","category":"section"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"Set P =  p_j(x^i)   ℝ^N  Q and Φ = φ( x^i - x^j ). The linear equation system for the coefficients of r is","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"    beginbmatrix\n    Φ  P \n    P^T  0_Q  Q\n    endbmatrix\n    beginbmatrix\n        w \n        λ\n    endbmatrix\n    =\n    beginbmatrix\n    Y\n    \n    0_Q\n    endbmatrix","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"We want a coefficients function and use the following helpers:","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"\"Evaluate each function in `funcs` on each vector in `sites`,\nso that each column corresponds to a function.\"\nfunction _func_matrix( funcs, sites )\n    # easy way:\n    ##[ funcs[j](sites[i]) for i = eachindex(sites), j = eachindex(funcs) ]\n\n    # Zygote-compatible\n    Φ = Buffer( sites[1], length(sites), length(funcs) )\n    for (i, func) ∈ enumerate(funcs)\n        Φ[:,i] = [ func( x ) for x ∈ sites ]\n    end\n    return copy(Φ)\nend","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"For now, we use the \\ operator to solve A * coeff = RHS:","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"@doc \"\"\"\n    coefficients(sites, values, kernels, polys )\n\nReturn the coefficient matrices `w` and `λ` for an rbf model\n``r(x) = Σ_{i=1}^N wᵢ kᵢ(x) + Σ_{j=1}^M λᵢ pᵢ(x)``,\nwhere ``N`` is the length of `kernels` and ``M``\nis the length of `polys`.\n\nThe arguments are\n* an array of data sites `sites` with vector entries from ``ℝ^n``.\n* an array of data values `values` with vector entries from ``ℝ^k``.\n* an array `kernels` of RBF basis functions (of type `ShiftedKernel`)\n* an array `polys` of polynomial basis functions.\n\"\"\"\nfunction coefficients( sites, values, kernels, polys )\n\n    # Φ-matrix, columns =̂ basis funcs, rows =̂ sites\n    N = length(sites);\n    Φ = _func_matrix( kernels, sites )\n\n    # P-matrix, N × Q\n    Q = length(polys)\n    P = _func_matrix( polys, sites )\n\n    # system matrix A\n    Z = zeros( eltype(Φ), Q, Q )\n    A = [ Φ  P;\n          P' Z ];\n\n    # build rhs (in a Zygote friendly way)\n    F = Buffer( values[1], length(values), length(values[1]) ) ## vals to matrix, columns =̂ outputs\n    for (i, val) ∈ enumerate(values)\n        F[i, :] = val\n    end\n    RHS = [\n        copy(F) ;\n        zeros( eltype(eltype(values)), Q, size(F,2) )\n    ];\n\n    # solve system\n    coeff = A \\ RHS\n\n    # return w and λ\n    return coeff[1 : N, :], coeff[N+1 : end, :]\nend","category":"page"},{"location":"RBFModels/#The-Model-Data-Type","page":"Module Description","title":"The Model Data Type","text":"","category":"section"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"We now have all ingredients to define the model type. We allow for vector valued data sites and determine multiple outputs if needed.","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"First, define some helper functions:","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"function convert_list_of_vecs( vec_type :: Type, list_of_vecs :: Vector{<:Union{Vector,SVector}} )\n    return vec_type.(list_of_vecs)\nend\n\n# allow for providing scalar data\nfunction convert_list_of_vecs( vec_type :: Type, list_of_vecs :: Vector{<:Real} )\n    return convert_list_of_vecs( vec_type, [ [x,] for x ∈ list_of_vecs ] )\nend\n\n# do nothing if types alreay match\nfunction convert_list_of_vecs(::Type{F}, list_of_vecs :: Vector{F} ) where F\n    return list_of_vecs\nend\n\n\"Return array of `ShiftedKernel`s based on `φ` with centers from `sites`.\"\nfunction make_kernels( φ :: RadialFunction, sites :: Union{Vector, SVector} )\n    return [ ShiftedKernel(φ, c) for c ∈ sites ]\nend\n\n\"Return array of `ShiftedKernel`s based functions in `φ_arr` with centers from `sites`.\"\nfunction make_kernels( φ :: Vector{RadialFunction}, sites :: Union{Vector, SVector} )\n    return [ ShiftedKernel(φ, c) for c ∈ sites ]\nend","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"The actual data type stores \n~~the (center) sites and data labels~~ \nthe coefficients and a (vector of) radial and polynomial basis function(s).","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"struct RBFInterpolationModel{S,F}\n    w :: Union{SMatrix{<:Int, <:Int, F, <:Int}, Matrix{F}}    # RBF weight matrix\n    λ :: Union{SMatrix{<:Int, <:Int, F, <:Int}, Matrix{F}}    # polynomial coefficient matrix\n    kernels :: Vector{<:ShiftedKernel}   # vector of RBF basis functions\n    polys :: Vector # polynomial basis functions\n\n    num_vars :: Int\n    num_outputs :: Int\n\n    function RBFInterpolationModel(\n        Sites :: Vector{ VecTypeS },\n        Values :: Vector{ VecTypeV },\n        φ :: Union{RadialFunction,Vector{<:RadialFunction}},\n        poly_deg :: Int;\n        static_arrays ::Union{Bool, Nothing} = nothing\n        ) where { VecTypeS, VecTypeV }\n\n        # data integrity checks\n        @assert length(Sites) == length(Values) \"Provide as many data sites as data labels.\"\n        @assert !isempty(Sites) \"Provide at least 1 data site.\"\n        num_vars = length(Sites[1])\n        num_outputs = length(Values[1])\n        @assert all( length(s) == num_vars for s ∈ Sites ) \"All sites must have same dimension.\"\n        @assert all( length(v) == num_outputs for v ∈ Values ) \"All values must have same dimension.\"\n\n        # use same precision everywhere ( at least half-precision )\n        TypeS = eltype( VecTypeS )\n        TypeV = eltype( VecTypeV )\n        dtype = promote_type( TypeS, TypeV, Float16 )\n\n        # use static arrays only if matrices are not big\n        if isnothing(static_arrays)\n            static_arrays = (num_vars <= 10 && num_outputs <= 10)\n        end\n\n        NewVecTypeS = static_arrays ? SVector{ num_vars, dtype } : Vector{dtype}\n        NewVecTypeV = static_arrays ? SVector{ num_outputs, dtype } : Vector{dtype}\n        sites = convert_list_of_vecs( NewVecTypeS, Sites )\n        values = convert_list_of_vecs( NewVecTypeV, Values )\n\n        kernels = make_kernels( φ, sites )\n        polys = canonical_basis( num_vars, poly_deg )\n\n        w, λ = coefficients( sites, values, kernels, polys )\n\n        new{static_arrays, dtype}( w, λ, kernels, polys, num_vars, num_outputs)\n    end\nend\n\n\"Evaluate `m` at vector `x`\"\nfunction (m :: RBFInterpolationModel{false,F} where F)( x :: Union{Vector, SVector} )\n    vec( _func_matrix( m.kernels, [x,] ) * m.w .+ _func_matrix( m.polys, [x,] )  * m.λ )\nend\n\n\"Evaluate `m` at vector `x`, using size information.\"\nfunction (m :: RBFInterpolationModel{true,F} where F)( x :: Union{Vector, SVector} )\n    vec(\n        SizedMatrix{ 1, length(m.kernels) }(_func_matrix( m.kernels, [x,] )) * m.w .+\n        SizedMatrix{ 1, length(m.polys) }(_func_matrix( m.polys, [x,] ) ) * m.λ\n    )\nend","category":"page"},{"location":"RBFModels/#Derivatives","page":"Module Description","title":"Derivatives","text":"","category":"section"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"Assume that φ is two times continuously differentiable. \nWhat is the gradient of an RBF model? Using the chain rule and ξ = x - x^j we get","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"dfracξ_i left( φ( ξ ) right)\n=\nφprime (  ξ  ) cdot\ndfracξ_i (  ξ  )\n=\nφprime (  ξ  ) cdot\ndfracξ_iξ","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"The right term is always bounded, but not well defined for ξ = 0 (see [wild_diss] for details). \nThat is why we require φ(0) stackrel= 0. \nWe have x_i ξ(x) = x - x^j and thus","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"r(x) = sum_i=1^N fracw_i φprime(  x - x^i  ) x - x^i  (x - x^i) + p(x)","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"For the Hessian Hr colon ℝ^n to ℝ^ntimes n we need the gradients of the component functions","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"    ψ_j(ξ) = frac φ( left ξ right )ξ ξ_j","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"Suppose ξ  0. First, using the product rule, we have","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"   dfracξ_i\n   left(\n   frac φ( left ξ right )ξ ξ_j =\n   ξ_j\n   right)\n   dfracξ_i\n   left(\n   frac φ( left ξ right )ξ\n   right)\n   +\n   frac φ( left ξ right )ξ\n   dfracξ_i\n   ξ_j","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"The last term is easy because of","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"fracξ_i ξ_j\n=\nbegincases\n    1  textif i = j\n    0  textelse\nendcases","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"For the first term we find","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"   dfracξ_i\n   left(\n     frac φ( left ξ right )\n      ξ\n   right)\n   =\n   frac\n       φleft(left ξ rightright) _i ξ\n       - ξ _i φleft( left ξ rightright)\n    \n        ξ^2\n    \n    =\n    frac\n        dfracφ(ξ)ξ ξ_i - ξφ(ξ)dfracξ_iξ\n    ξ^2","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"Hence, the gradient of ψ_j is","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"    ψ_j(ξ)\n    =\n    left( fracφ(ξ)ξ^3\n    -\n    fracφ(ξ)ξ^2 right) cdot ξ\n    -fracφ(ξ)ξ e^j","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"where e^j  ℝ^n is all zeros, except e^j_j = 1. For ξ = 0 the first term vanishes due to L'Hôpital's rule:","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"Ψ_j(0) = φ(0) e^j","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"[wild_diss]: “Derivative-Free Optimization Algorithms For Computationally Expensive Functions”, Wild, 2009.","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"[wendland]: “Scattered Data Approximation”, Wendland","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"","category":"page"},{"location":"RBFModels/","page":"Module Description","title":"Module Description","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = RBFModels","category":"page"},{"location":"#RBFModels","page":"Home","title":"RBFModels","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [RBFModels]","category":"page"},{"location":"#RBFModels.RBFInterpolationModel-Tuple{Union{Vector{T} where T, StaticArrays.SVector{S, T} where {S, T}}}","page":"Home","title":"RBFModels.RBFInterpolationModel","text":"Evaluate m at vector x, using size information.\n\n\n\n\n\n","category":"method"},{"location":"#RBFModels._func_matrix-Tuple{Any, Any}","page":"Home","title":"RBFModels._func_matrix","text":"Evaluate each function in funcs on each vector in sites,  so that each column corresponds to a function.\n\n\n\n\n\n","category":"method"},{"location":"#RBFModels.canonical_basis-Tuple{Int64, Int64}","page":"Home","title":"RBFModels.canonical_basis","text":"canonical_basis( n:: Int, d :: Int )\n\nReturn the canonical basis of the space of n-variate  polynomials of degree at most d.\n\n\n\n\n\n","category":"method"},{"location":"#RBFModels.coefficients-NTuple{4, Any}","page":"Home","title":"RBFModels.coefficients","text":"coefficients(sites, values, kernels, polys )\n\nReturn the coefficient matrices w and λ for an rbf model  r(x) = Σ_i=1^N wᵢ kᵢ(x) + Σ_j=1^M λᵢ pᵢ(x), where N is the length of kernels and M is the length of polys.\n\nThe arguments are \n\nan array of data sites sites with vector entries from ℝ^n.\nan array of data values values with vector entries from ℝ^k.\nan array kernels of RBF basis functions (of type ShiftedKernel)\nan array polys of polynomial basis functions.\n\n\n\n\n\n","category":"method"},{"location":"#RBFModels.make_kernels-Tuple{RBFModels.RadialFunction, Union{Vector{T} where T, StaticArrays.SVector{S, T} where {S, T}}}","page":"Home","title":"RBFModels.make_kernels","text":"Return array of ShiftedKernels based on φ with centers from sites.\n\n\n\n\n\n","category":"method"},{"location":"#RBFModels.make_kernels-Tuple{Vector{RBFModels.RadialFunction}, Union{Vector{T} where T, StaticArrays.SVector{S, T} where {S, T}}}","page":"Home","title":"RBFModels.make_kernels","text":"Return array of ShiftedKernels based functions in φ_arr with centers from sites.\n\n\n\n\n\n","category":"method"},{"location":"#RBFModels.non_negative_solutions-Tuple{Int64, Int64}","page":"Home","title":"RBFModels.non_negative_solutions","text":"non_negative_solutions( d :: Int, n :: Int)\n\nReturn array of solution vectors [x1, …, xn] to the equation x_1 +  + x_n = d where the variables are non-negative integers.\n\n\n\n\n\n","category":"method"}]
}
