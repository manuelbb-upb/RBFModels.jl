var documenterSearchIndex = {"docs":
[{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"EditURL = \"https://github.com/manuelbb-upb/RBFModels.jl/blob/master/src/RBFModels.jl\"","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"export auto_grad, auto_jac, grad, jac, eval_and_auto_grad\nexport eval_and_auto_jac, eval_and_grad, eval_and_jac","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"Dependencies of this module:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"using StaticPolynomials\nusing ThreadSafeDicts\nusing Memoization: @memoize\nusing StaticArrays\nusing LinearAlgebra: norm\nusing Lazy: @forward\n\nimport Flux.Zygote as Zyg\nusing Flux.Zygote: Buffer","category":"page"},{"location":"RBFModels/#Radial-Basis-Function-Models","page":"Main Module","title":"Radial Basis Function Models","text":"","category":"section"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"The sub-module RBFModels provides utilities to work with radial basis function [RBF] models. Given N data sites X =  x^1  x^N   ℝ^n and values Y =  y^1  y^N   ℝ, an interpolating RBF model rcolon ℝ^n  ℝ has the form","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"r(x) = sum_i=1^N w_i φ(  x - x^i _2 ) + p(x)","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"where p is a multivariate polynomial. The radial function φcolon 0 ) to ℝ defines the RBF and we can solve for the coefficients w by solving the interpolation system","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"r( x^i ) stackrel= y^i quad textfor all i=1N","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"For the interpolation system to be solvable we have to choose the right polynomial space for p. Basically, if the RBF Kernel (or the radial function) is conditionally positive definite of order D we have to find a polynomial p with deg p ge D-1.[wendland] If the kernel is CPD of order D=0 we do not have to add an polynomial and can interpolate arbitrary (distinct) data points. \nNow let p_j_1le jle Q be a basis of the polynomial space. Set P =  p_j(x^i)   ℝ^N  Q and Φ = φ( x^i - x^j ). In case of interpolation, the linear equation system for the coefficients of r is","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"    beginbmatrix\n    Φ  P \n    P^T  0_Q  Q\n    endbmatrix\n    beginbmatrix\n        w \n        λ\n    endbmatrix\n    =\n    beginbmatrix\n    Y\n    \n    0_Q\n    endbmatrix","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"We can also use differing feature vectors and centers. It is also possible to determine a least squarse solution to a overdetermined system. Hence, we will denote the number of kernel centers by N_c from now on.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"note: Note\nWhen we have vector data Y  ℝ^k, e.g. from modelling MIMO functions, then Julia easily allows for multiple columns in the righthand side of the interpolation equation system and we get weight vectors for multiple models, that can be thought of as one vector models rcolon ℝ^n to ℝ.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"note: Note\nSee the section about Constructors for how we actually solve the equation system.","category":"page"},{"location":"RBFModels/#Radial-Basis-Function-Sum.","page":"Main Module","title":"Radial Basis Function Sum.","text":"","category":"section"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"The function k() = φ(_2) is radially symmetric around the origin. k is called the kernel of an RBF.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"We define an abstract super type for radial functions:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"abstract type RadialFunction <: Function end","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"Each Type that inherits from RadialFunction should implement an evaluation method. It takes the radius/distance ρ = ρ(x) =  x - x^i  from x to a specific center x^i.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"(φ :: RadialFunction )( ρ :: Real ) :: Real = Nothing;\nnothing #hide","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"We also need the so called order of conditional positive definiteness:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"cpd_order( φ :: RadialFunction) :: Int = nothing;\nnothing #hide","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"The derivative can also be specified. It defaults to","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"df( φ :: RadialFunction, ρ ) = Zyg.gradient( φ, ρ )[1]","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"The file radial_funcs.jl contains various radial function implementations.","category":"page"},{"location":"RBFModels/#Some-Radial-Functions","page":"Main Module","title":"Some Radial Functions","text":"","category":"section"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"The Gaussian is defined by φ(ρ) = exp left( - (αρ)^2 right), where α is a shape parameter to fine-tune the function.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"\"\"\"\n    Gaussian( α = 1 ) <: RadialFunction\n\nA `RadialFunction` with\n```math\n    φ(ρ) = \\\\exp( - (α ρ)^2 ).\n```\n\"\"\"\nstruct Gaussian{R<:Real} <: RadialFunction\n    α :: R\n\n    function Gaussian( α :: R = 1 ) where R<:Real\n        @assert α > 0 \"The shape parameter `α` must be positive.\"\n        return new{R}(α)\n    end\nend\n\nfunction ( φ :: Gaussian )( ρ :: Real )\n    exp( - (φ.α * ρ)^2 )\nend\n\ncpd_order( :: Gaussian ) = 0\ndf(φ :: Gaussian, ρ :: Real) = - 2 * φ.α^2 * ρ * φ( ρ )","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"The Multiquadric is φ(ρ) = - sqrt 1 + (αρ)^2  and also has a positive shape parameter. We can actually generalize it to the following form:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"\"\"\"\n    Multiquadric( α = 1, β = 1//2 ) <: RadialFunction\n\nA `RadialFunction` with\n```math\n    φ(ρ) = (-1)^{ \\\\lceil β \\\\rceil } ( 1 + (αρ)^2 )^β\n```\n\"\"\"\nstruct Multiquadric{R<:Real,S<:Real} <: RadialFunction\n    α :: R   # shape parameter\n    β :: S   # exponent\n\n    function Multiquadric(α :: R = 1, β :: S = 1//2 ) where {R<:Real, S<:Real}\n        @assert α > 0 \"The shape parameter `α` must be positive.\"\n        @assert β % 1 != 0 \"The exponent must not be an integer.\"\n        @assert β > 0 \"The exponent must be positive.\"\n        new{R,S}(α,β)\n    end\nend\n\nfunction ( φ :: Multiquadric )( ρ :: Real )\n    (-1)^(ceil(Int, φ.β)) * ( 1 + (φ.α * ρ)^2 )^φ.β\nend\n\ncpd_order( φ :: Multiquadric ) = ceil( Int, φ.β )\ndf(φ :: Multiquadric, ρ :: Real ) = (-1)^(ceil(Int, φ.β)) * 2 * φ.α * φ.β * ρ * ( 1 + (φ.α * ρ)^2 )^(φ.β - 1)","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"Related is the Inverse Multiquadric φ(ρ) = (1+(αρ)^2)^-β is related:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"\"\"\"\n    InverseMultiquadric( α = 1, β = 1//2 ) <: RadialFunction\n\nA `RadialFunction` with\n```math\n    φ(ρ) = ( 1 + (αρ)^2 )^{-β}\n```\n\"\"\"\nstruct InverseMultiquadric{R<:Real,S<:Real} <: RadialFunction\n    α :: R\n    β :: S\n\n    function InverseMultiquadric( α :: Real = 1, β :: Real = 1//2 ) where {R<:Real, S<:Real}\n        @assert α > 0 \"The shape parameter `α` must be positive.\"\n        @assert β > 0 \"The exponent must be positive.\"\n        new{R,S}(α, β)\n    end\nend\n\nfunction ( φ :: InverseMultiquadric )( ρ :: Real )\n   ( 1 + (φ.α * ρ)^2 )^(-φ.β)\nend\n\ncpd_order( :: InverseMultiquadric ) = 0\ndf(φ :: InverseMultiquadric, ρ :: Real ) = - 2 * φ.α^2 * φ.β * ρ * ( 1 + (φ.α * ρ)^2 )^(-φ.β - 1)","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"The Cubic is φ(ρ) = ρ^3. It can also be generalized:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"\"\"\"\n    Cubic( β = 3 ) <: RadialFunction\n\nA `RadialFunction` with\n```math\n    φ(ρ) = (-1)^{ \\\\lceil β \\\\rceil /2 } ρ^β\n```\n\"\"\"\nstruct Cubic{R<:Real} <: RadialFunction\n    β :: R\n\n    function Cubic( β :: R = 3 ) where R<:Real\n        @assert β > 0 \"The exponent `β` must be positive.\"\n        @assert β % 2 != 0 \"The exponent `β` must not be an even number.\"\n        new{R}(β)\n    end\nend\n\nfunction ( φ :: Cubic )( ρ :: Real )\n    (-1)^ceil(Int, φ.β/2 ) * ρ^φ.β\nend\n\ncpd_order( φ :: Cubic ) = ceil( Int, φ.β/2 )\ndf(φ :: Cubic, ρ :: Real ) = (-1)^(ceil(Int, φ.β/2)) * φ.β * ρ^(φ.β - 1)","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"The thin plate spline is usually defined via φ(ρ) = ρ^2 log( ρ ). We provide a generalized version, which defaults to φ(ρ) = - ρ^4 log( ρ ).","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"\"\"\"\n    ThinPlateSpline( k = 2 ) <: RadialFunction\n\nA `RadialFunction` with\n```math\n    φ(ρ) = (-1)^{k+1} ρ^{2k} \\\\log(ρ)\n```\n\"\"\"\nstruct ThinPlateSpline <: RadialFunction\n    k :: Int\n\n    ThinPlateSpline( k :: Real = 2 ) = begin\n        @assert k > 0 && k % 1 == 0 \"The parameter `k` must be a positive integer.\"\n        new( Int(k) )\n    end\nend\n\nfunction (φ :: ThinPlateSpline )( ρ :: Real )\n    (-1)^(k+1) * ρ^(2*k) * log( ρ )\nend\n\ncpd_order( φ :: ThinPlateSpline ) = φ.k + 1\ndf(φ :: ThinPlateSpline, ρ :: Real ) = ρ == 0 ? 0 : (-1)^(φ.k+1) * ρ^(2*φ.k - 1) * ( 2 * φ.k * log(ρ) + 1)","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"note: Note\nThe thin plate spline with k = 1 is not differentiable at ρ=0 but we define the derivative as 0, which makes results in a continuous extension.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"From an RadialFunction and a vector we can define a shifted kernel function.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"const NumberOrVector = Union{<:Real, AbstractVector{<:Real}}\n\nstruct ShiftedKernel{RT <: RadialFunction, CT <: AbstractVector{<:Real}} <: Function\n    φ :: RT\n    c :: CT\nend\n\nnorm2( vec ) = norm(vec, 2)\n\n\"Evaluate kernel `k` at `x - k.c`.\"\nfunction (k::ShiftedKernel)( x :: AbstractVector{<:Real} )\n    return k.φ( norm2( x - k.c ) )\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"A vector of N kernels is a mapping ℝ^n  ℝ^N  x   k₁(x)  k_N(x).","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"\"Evaluate ``x ↦ [ k₁(x), …, k_{N_c}(x)]`` at `x`.\"\nfunction ( K::AbstractVector{<:ShiftedKernel})( x :: AbstractVector{<:Real} )\n    [ k(x) for k ∈ K ]\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"Suppose, we have calculated the distances x - x^i beforehand. We can save redundant effort by passing them to the radial fucntions of the kernels.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"\"Evaluate `k.φ` for distance `ρ` where `ρ` should equal `x - k.c` for the argument `x`.\"\neval_at_dist( k :: ShiftedKernel , ρ :: Real ) = k.φ(ρ)\n\n\"Evaluate ``x ↦ [ k₁(x), …, k_{N_c}(x)]``, provided the distances ``[ ρ_1(x), …, ρ_{N_c}(x) ]``.\"\nfunction eval_at_dist( K::AbstractVector{<:ShiftedKernel}, dists :: AbstractVector{<:Real})\n    [ eval_at_dist(k,ρ) for (k,ρ) ∈ zip(K,dists) ]\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"Provided we have solved the interpolation system, the weights for the radial basis function part of r are w, where w is a vector of length N_c or a matrix in ℝ^N_c times k where k is the number of outputs. We treat the general case kge 1 and always assume w to be a matrix.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"struct RBFSum{\n    KT <: AbstractVector{<:ShiftedKernel},\n    WT <: AbstractMatrix{<:Real}\n}\n    kernels :: KT\n    weights :: WT # can be a normal matrix or a SMatrix\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"Make it display nicely:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"function Base.show( io :: IO, rbf :: RBFSum{KT,WT} ) where {KT, WT}\n    compact = get(io, :compact, false)\n    if compact\n        print(io, \"RBFSum{$(KT), $(WT)}\")\n    else\n        n_out, n_kernels = size(rbf.weights)\n        print(io, \"RBFSum\\n\")\n        print(io, \"* with $(n_kernels) kernels in an array of type $(KT)\\n\")\n        print(io, \"* and a $(n_kernels)×$(n_out) weight matrix of type $(WT).\")\n    end\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"We can easily evaluate the ℓ-th output of the RBFPart.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"\"Evaluate output `ℓ` of RBF sum `rbf::RBFSum`\"\nfunction (rbf :: RBFSum)(x :: AbstractVector{<:Real}, ℓ :: Int)\n    (rbf.weights[ℓ,:]'rbf.kernels(x))[1]\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"Use the above method for vector-valued evaluation of the whole sum:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"\"Evaluate `rbf::RBFSum` at `x`.\"\n(rbf::RBFSum)( x :: AbstractVector{<:Real} ) = vec(rbf.weights*rbf.kernels(x))","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"As before, we allow to pass precalculated distance vectors:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"function eval_at_dist( rbf::RBFSum, dists :: AbstractVector{<:Real}, ℓ :: Int )\n   rbf.weights[ℓ,:]'eval_at_dist( rbf.kernels, dists )\nend\n\nfunction eval_at_dist( rbf :: RBFSum, dists :: AbstractVector{<:Real})\n   vec(rbf.weights*eval_at_dist(rbf.kernels, dists ))\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"For the PolynomialTail do something similar and use a StaticPolynomials.PolynomialSystem with a weight matrix.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"# TODO: Whenever I pass a type (e.g. `Int`), is it better to pass `R`?","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"If the polynomial degree is < 0, we use an EmptyPolySystem:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"\"Drop-In Alternative to `StaticPolynomials.PolynomialSystem` when there are no outputs.\"\nstruct EmptyPolySystem{Nvars} end\nBase.length(::EmptyPolySystem) = 0\nStaticPolynomials.npolynomials(::EmptyPolySystem) = 0\n\n\"Evaluate for usual vector input. (Scalar input also supported, there are no checks)\"\nStaticPolynomials.evaluate(:: EmptyPolySystem, :: Union{R, Vector{R}}) where R<:Real = Int[]\n\"Evaluate for sized input.\"\nStaticPolynomials.evaluate(:: EmptyPolySystem{Nvars}, :: StaticVector ) where {Nvars} = SVector{0,Int}()\n(p :: EmptyPolySystem)( x :: NumberOrVector) = evaluate(p, x)\n\nfunction StaticPolynomials.jacobian( :: EmptyPolySystem{Nvars}, args... ) where Nvars\n    Matrix{Int}(undef, 0, Nvars )\nend\n\nfunction StaticPolynomials.evaluate_and_jacobian( p :: EmptyPolySystem, args ... )\n    return p(args...), jacobian(p, args...)\nend\nstruct PolySum{\n        PS <: Union{EmptyPolySystem, PolynomialSystem},\n        WT <: AbstractMatrix\n    }\n    polys :: PS\n    weights :: WT       # n_out × n_polys matrix\n\n    function PolySum( polys :: PS, weights :: WT) where{PS, WT}\n        _, n_polys = size(weights)\n        @assert npolynomials(polys) == n_polys \"Number of polynomials does not macth.\"\n        new{PS,WT}(polys, weights)\n    end\nend\n\n(p :: PolySum)(x) = p.weights*p.polys(x)\n(p :: PolySum)(x,ℓ::Int) = (p.weights[ℓ,:]'p.polys(x))[end]","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"We now have all ingredients to define the model type.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"\"\"\"\n    RBFModel{V}\n\n* `V` is `true` by default. It can be set to `false` only if the number\n  of outputs is 1. Then scalars are returned.\n\n\"\"\"\nstruct RBFModel{V,\n        RS <: RBFSum,\n        PS <: PolySum }\n    rbf :: RS\n    psum :: PS\n\n    # Information fields\n    num_vars :: Int\n    num_outputs :: Int\n    num_centers :: Int\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"We want a model to be displayed in a sensible way:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"function Base.show( io :: IO, mod :: RBFModel{V,RS,PS} ) where {V,RS,PS}\n    compact = get(io, :compact, false)\n    if compact\n        print(io, \"$(mod.num_vars)D$(mod.num_outputs)D-RBFModel{$(V)}\")\n    else\n        print(io, \"RBFModel{$(V),$(RS),$(PS)}\\n\")\n        if V\n            print(io, \"\\twith vector output \")\n        else\n            print(io, \" with scalar output \")\n        end\n        print(io, \"and $(mod.num_centers) centers, \")\n        print(io, \"mapping from ℝ^$(mod.num_vars) to ℝ^$(mod.num_outputs).\")\n    end\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"Evaluation is easy. We accept an additional ::Nothing argument that does nothing for now, but saves some typing later.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"function vec_eval(mod :: RBFModel, x :: AbstractVector{<:Real}, :: Nothing)\n    return mod.rbf(x) .+ mod.psum( x )\nend\n\nfunction scalar_eval(mod :: RBFModel, x :: AbstractVector{<:Real}, :: Nothing )\n    return (mod.rbf(x) .+ mod.psum( x ))[1]\nend\n\n\"Evaluate model `mod :: RBFModel` at vector `x`.\"\n( mod :: RBFModel{true, RS, PS} where {RS,PS} )(x :: AbstractVector{<:Real}, ℓ :: Nothing = nothing ) = vec_eval(mod,x,ℓ)\n( mod :: RBFModel{false, RS, PS} where {RS,PS} )(x :: AbstractVector{<:Real}, ℓ :: Nothing = nothing ) = scalar_eval(mod,x,ℓ)\n\n\"Evaluate scalar output `ℓ` of model `mod` at vector `x`.\"\nfunction (mod :: RBFModel)( x :: AbstractVector{<:Real}, ℓ :: Int)\n    return mod.rbf(x, ℓ) .+ mod.psum( x, ℓ )\nend\n\n# scalar input\nconst NothInt = Union{Nothing,Int}\n\nfunction (mod :: RBFModel)(x :: Real, ℓ :: NothInt = nothing )\n    @assert mod.num_vars == 1 \"The model has more than 1 inputs. Provide a vector `x`, not a number.\"\n    mod( [x,], ℓ)\nend","category":"page"},{"location":"RBFModels/#Derivatives","page":"Main Module","title":"Derivatives","text":"","category":"section"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"The easiest way to provide derivatives is via Automatic Differentiation. We have imported Flux.Zygote as Zyg. For automatic differentiation we need custom adjoints for some StaticArrays:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"Zyg.@adjoint (T::Type{<:SizedMatrix})(x::AbstractMatrix) = T(x), dv -> (nothing, dv)\nZyg.@adjoint (T::Type{<:SizedVector})(x::AbstractVector) = T(x), dv -> (nothing, dv)\nZyg.@adjoint (T::Type{<:SArray})(x::AbstractArray) = T(x), dv -> (nothing, dv)","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"This allows us to define the following methods:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"\"Return the jacobian of `rbf` at `x` (using Zygote).\"\nfunction auto_jac( rbf :: RBFModel, x :: AbstractVector{<:Real} )\n    Zyg.jacobian( rbf, x )[1]\nend\n\n\"Evaluate the model and return the jacobian at the same time.\"\nfunction eval_and_auto_jac( rbf :: RBFModel, x :: AbstractVector{<:Real} )\n    y, back = Zyg._pullback( rbf, x )\n\n    T = eltype(y)   # TODO does this make sense?\n    n = length(y)\n    jac = zeros(T, n, length(x) )\n    for i = 1 : length(x)\n        e = [ zeros(T, i -1 ); T(1); zeros(T, n - i )  ]\n        jac[i, :] .= back(e)[2]\n    end\n\n    return y, jac\nend\n\n\"Return gradient of output `ℓ` of model `rbf` at point `x` (using Zygote).\"\nfunction auto_grad( rbf :: RBFModel, x :: AbstractVector{<:Real}, ℓ :: Int = 1)\n    Zyg.gradient( χ -> rbf(χ, ℓ), x )[1]\nend\n\n\"Evaluate output `ℓ` of the model and return the gradient.\"\nfunction eval_and_auto_grad( rbf :: RBFModel, x :: AbstractVector{<:Real}, ℓ :: Int = 1 )\n    y, back = Zyg._pullback( χ -> rbf(χ, ℓ)[end], x)\n\n    grad = back( one(y) )[2]\n    return y, grad\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"note: Note\nWe need at least ChainRules@v.0.7.64 to have auto_grad etc. work for StaticArrays, see this issue.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"But we don't need Zygote, because we can derive the gradients ourselves. Assume that φ is two times continuously differentiable. \nWhat is the gradient of a scalar RBF model? Using the chain rule and ξ = x - x^j we get","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"dfracξ_i left( φ( ξ ) right)\n=\nφprime (  ξ  ) cdot\ndfracξ_i (  ξ  )\n=\nφprime (  ξ  ) cdot\ndfracξ_iξ","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"The right term is always bounded, but not well defined for ξ = 0 (see [wild_diss] for details). \nThat is why we require φ(0) stackrel= 0. \nWe have dfracx_i ξ(x) = 1 and thus","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"r(x) = sum_i=1^N fracw_i φprime(  x - x^i  ) x - x^i  (x - x^i) + p(x)","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"We can then implement the formula from above. For a fixed center x^i let o be the distance vector x - x^i and let ρ be the norm ρ = o =  x- x^i . Then, the gradient of a single kernel is:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"function grad( k :: ShiftedKernel, o :: AbstractVector{<:Real}, ρ :: Real )\n    ρ == 0 ? zero(k.c) : (df( k.φ, ρ )/ρ) .* o\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"In terms of x:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"function grad( k :: ShiftedKernel, x :: AbstractVector{<:Real} )\n    o = x - k.c     # offset vector\n    ρ = norm2( o )  # distance\n    return grad( k, o, ρ )\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"The jacobion of a vector of kernels follows suit:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"function jacT( K :: AbstractVector{<:ShiftedKernel}, x :: AbstractVector{<:Real})\n    hcat( ( grad(k,x) for k ∈ K )... )\nend\n# precalculated offsets and distances, 1 per kernel\nfunction jacT( K :: AbstractVector{<:ShiftedKernel}, offsets :: AbstractVector{<:AbstractVector}, dists :: AbstractVector{<:Real} )\n    hcat( ( grad(k,o,ρ) for (k,o,ρ) ∈ zip(K,offsets,dists) )... )\nend\njac( K :: AbstractVector{<:ShiftedKernel}, args... ) = transpose( jacT(K, args...) )","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"Hence, the gradients of an RBFSum are easy:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"function grad( rbf :: RBFSum, x :: AbstractVector{<:Real}, ℓ :: Int = 1 )\n    #vec( jacT( rbf.kernels, x) * rbf.weights[:,ℓ] )\n    vec( rbf.weights[ℓ,:]'jac( rbf.kernels, x ) )\nend\n\nfunction grad( rbf :: RBFSum, offsets :: AbstractVector{<:AbstractVector}, dists :: AbstractVector{<:Real}, ℓ :: Int)\n    return vec( rbf.weights[ℓ,:]'jac( rbf.kernels, offsets, dists ) )\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"The grad method looks very similar for the PolySum. We obtain the jacobian of the polynomial basis system via PolynomialSystem.jacobian.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"function grad( psum :: PolySum, x :: AbstractVector{<:Real} , ℓ :: Int = 1)\n    return vec( psum.weights[ℓ,:]'jacobian( psum.polys, x ))\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"For the RBFModel we simply combine both methods:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"function _grad( mod :: RBFModel, x :: AbstractVector{<:Real}, ℓ :: Int = 1 )\n    return grad(mod.rbf, x, ℓ) + grad( mod.psum, x, ℓ )\nend\n\nfunction grad( mod :: RBFModel, x :: Vector{<:Real}, ℓ :: Int = 1 )\n    G = _grad(mod, x, ℓ)\n\n    if G isa Vector\n        return G\n    else\n        return [ G.data... ]\n    end\nend\n\nfunction grad( mod :: RBFModel, x :: StaticVector{T, R} where{T, R<:Real}, ℓ :: Int = 1 )\n    G = _grad(mod, x, ℓ)\n\n    if G isa StaticArray\n        return G\n    else\n        return SizedVector{mod.num_vars}(G)\n    end\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"We can exploit our custom evaluation methods for \"distances\":","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"function _offsets_and_dists( rbf :: RBFSum, x :: AbstractVector{<:Real} )\n    offsets = [ x - k.c for k ∈ rbf.kernels ]\n    dists = norm2.(offsets)\n    return offsets, dists\nend\n\nfunction eval_and_grad( rbf :: RBFSum, offsets :: AbstractVector{<:AbstractVector}, dists :: AbstractVector{<:Real}, ℓ :: Int)\n    return eval_at_dist( rbf, dists, ℓ ), grad( rbf, offsets, dists, ℓ)\nend\n\nfunction eval_and_grad( rbf :: RBFSum, x :: AbstractVector{<:Real}, ℓ :: Int = 1)\n    offsets, dists = _offsets_and_dists(rbf, x)\n    return eval_and_grad( rbf, offsets, dists, ℓ)\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"For the PolySum we use evaluate_and_jacobian.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"function eval_and_grad( psum :: PolySum, x :: AbstractVector{<:Real}, ℓ :: Int = 1)\n    res_p, J_p = evaluate_and_jacobian( psum.polys, x )\n    return (psum.weights[ℓ,:]'res_p)[1], vec(psum.weights[ℓ,:]'J_p)\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"Combine for RBFModel:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"function eval_and_grad( mod :: RBFModel, x :: AbstractVector{<:Real}, ℓ :: Int = 1 )\n    res_rbf, g_rbf = eval_and_grad( mod.rbf, x, ℓ )\n    res_polys, g_polys = eval_and_grad( mod.psum, x, ℓ )\n    return res_rbf + res_polys, g_rbf + g_polys\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"For the jacobian, we use the same trick to save evaluations.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"function jac( rbf :: RBFSum, x :: AbstractVector{<:Real} )\n    offsets, dists = _offsets_and_dists(rbf, x)\n    rbf.weights * jac( rbf.kernels, offsets, dists )\nend\njacT(rbf :: RBFSum, args... ) = transpose( jac(rbf, args...) )\n\nfunction jac( psum :: PolySum, x :: AbstractVector{<:Real} )\n    psum.weights * jacobian( psum.polys, x )\nend\n\nfunction _jac( mod :: RBFModel, x :: AbstractVector{<:Real} )\n    jac( mod.rbf, x ) + jac( mod.psum, x)\nend\n\nfunction jac( mod :: RBFModel, x :: Vector{R}) where R<:Real\n    Matrix( _jac(mod, x) )\nend\n\nfunction jac( mod :: RBFModel, x :: StaticVector{T, R} ) where{T, R<:Real}\n    J = _jac(mod, x)\n    if J isa StaticArray\n        return J\n    else\n        return SizedMatrix{mod.num_outputs, mod.num_vars}(J)\n    end\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"As before, define an \"evaluate-and-jacobian\" function that saves evaluations:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"function eval_and_jac( rbf :: RBFSum, x :: AbstractVector{<:Real} )\n    offsets, dists = _offsets_and_dists(rbf, x)\n    res = eval_at_dist( rbf, dists )\n    J = rbf.weights * jac( rbf.kernels, offsets, dists )\n    return res, J\nend\n\nfunction eval_and_jac( psum :: PolySum, x :: AbstractVector{<:Real} )\n    res_p, J_p = evaluate_and_jacobian( psum.polys, x )\n    return vec( psum.weights * res_p ), psum.weights * J_p\nend\n\nfunction eval_and_jac( mod :: RBFModel, x :: AbstractVector{<:Real} )\n    res_rbf, J_rbf = eval_and_jac( mod.rbf, x )\n    res_polys, J_polys = eval_and_jac( mod.psum, x)\n    return res_rbf + res_polys, J_rbf + J_polys\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"note: Note\nHessians are not yet implemented.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"For the Hessian Hr colon ℝ^n to ℝ^ntimes n we need the gradients of the component functions","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"    ψ_j(ξ) = frac φ( left ξ right )ξ ξ_j","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"Suppose ξ  0. First, using the product rule, we have","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"   dfracξ_i\n   left(\n   frac φ( left ξ right )ξ ξ_j\n   right) =\n   ξ_j\n   dfracξ_i\n   left(\n   frac φ( left ξ right )ξ\n   right)\n   +\n   frac φ( left ξ right )ξ\n   dfracξ_i\n   ξ_j","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"The last term is easy because of","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"fracξ_i ξ_j\n=\nbegincases\n    1  textif i = j\n    0  textelse\nendcases","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"For the first term we find","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"   dfracξ_i\n   left(\n     frac φ( left ξ right )\n      ξ\n   right)\n   =\n   frac\n       φleft(left ξ rightright) _i ξ\n       - ξ _i φleft( left ξ rightright)\n    \n        ξ^2\n    \n    =\n    frac\n        dfracφ(ξ)ξ ξ_i - ξφ(ξ)dfracξ_iξ\n    ξ^2","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"Hence, the gradient of ψ_j is","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"    ψ_j(ξ)\n    =\n    left( fracφ(ξ)ξ^3\n    -\n    fracφ(ξ)ξ^2 right) cdot ξ\n    -fracφ(ξ)ξ e^j","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"where e^j  ℝ^n is all zeros, except e^j_j = 1. For ξ = 0 the first term vanishes due to L'Hôpital's rule:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"ψ_j(0) = φ(0) e^j","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"This file is included from within RBFModels.jl #src","category":"page"},{"location":"RBFModels/#Constructors","page":"Main Module","title":"Constructors","text":"","category":"section"},{"location":"RBFModels/#Polynomial-Basis","page":"Main Module","title":"Polynomial Basis","text":"","category":"section"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"Any constructor of an RBFModel must solve for the coefficients. To build the equation system, we need a basis p_j_1 le j le Q of Π_d(ℝ^n).","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"The canonical basis is x_1^α_1 x_2^α_2  x_n^α_n with α_i  0 and Σ_i α_i  d. For bard le d we can recursively get the non-negative integer solutions for Σ_i α_i = bard with the following function:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"@doc \"\"\"\n    non_negative_solutions( d :: Int, n :: Int)\n\nReturn a matrix with columns that correspond to solution vectors\n``[x_1, …, x_n]`` to the equation ``x_1 + … + x_n = d``,\nwhere the variables are non-negative integers.\n\"\"\"\nfunction non_negative_solutions( d :: Int, n :: Int )\n    if n == 1\n        return fill(d,1,1)\n    else\n        num_sols = binomial( d + n - 1, n - 1)\n        sol_matrix = Matrix{Int}(undef, n, num_sols)\n        j = 1\n        for i = 0 : d\n            # find all solutions of length `n-1` that sum to `i`\n            # if add `d-i` to each column, then each column\n            # has `n` elements and sums to `d`\n            padded_shorter_solutions = vcat( d-i, non_negative_solutions(i, n-1) )\n            num_shorter_sols = size( padded_shorter_solutions, 2 )\n            sol_matrix[:, j : j + num_shorter_sols - 1] .= padded_shorter_solutions\n            j += num_shorter_sols\n        end\n        return sol_matrix\n    end\nend\n\nfunction non_negative_solutions_ineq( d :: Int, n :: Int )\n    return hcat( (non_negative_solutions( d̄, n ) for d̄=0:d )... )\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"note: Note\nI did an unnecessary rewrite of non_negative_solutions to be Zygote-compatible. Therefore the buffers...","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"Combinatorics has multiexponents which should do the same...","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"We don't use DynamicPolynomials.jl to generate the Polyomials anymore. Zygote did overflow when there were calculations with those polynomials. Not a problem for calculating the basis (because of @nograd), but when constructing the outputs from them. Instead we directly construct StaticPolynomials.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"##@memoize ThreadSafeDict\n@doc \"\"\"\n    canonical_basis( n:: Int, d :: Int ) :: Union{PolynomialSystem, EmptyPolySystem}\n\nReturn the canonical basis of the space of `n`-variate\npolynomials of degree at most `d`.\n\"\"\"\nZyg.@nograd function canonical_basis( n :: Int, d :: Int )\n    if d < 0\n        return EmptyPolySystem{n}()\n    else\n        exponent_matrix = non_negative_solutions_ineq( d, n )\n        return PolynomialSystem( ( Polynomial( [1,], e[:,:] ) for e ∈ eachcol(exponent_matrix) )... )\n    end\nend","category":"page"},{"location":"RBFModels/#Solving-the-Equation-System","page":"Main Module","title":"Solving the Equation System","text":"","category":"section"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"For now, we use the \\ operator to solve A * coeff = RHS. Furthermore, we allow for different interpolation sites and RBF centers by allowing for passing kernels.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"const VecOfVecs{T} = AbstractVector{<:AbstractVector}\n\n@doc \"\"\"\n    coefficients(sites, values, kernels, rad_funcs, polys )\n\nReturn the coefficient matrices `w` and `λ` for an rbf model\n``r(x) = Σ_{i=1}^N wᵢ φ(\\\\|x - x^i\\\\|) + Σ_{j=1}^M λᵢ pᵢ(x)``,\nwhere ``N`` is the length of `rad_funcs` (and `centers`) and ``M``\nis the length of `polys`.\n\nThe arguments are\n* an array of data sites `sites` with vector entries from ``ℝ^n``.\n* an array of data values `values` with vector entries from ``ℝ^k``.\n* an array of `ShiftedKernel`s.\n* a `PolynomialSystem` or `EmptyPolySystem` (in case of deg = -1).\n\"\"\"\nfunction coefficients(\n        sites :: ST,\n        values :: VT,\n        kernels :: AbstractVector{<:ShiftedKernel},\n        polys :: Union{PolynomialSystem,EmptyPolySystem} #Vector{<:DP.Polynomial};\n    ) where {ST <: AbstractVector, VT <: AbstractVector }\n\n    n_out = length(values[1])\n    S = length(sites)\n\n    # Φ-matrix, S × N, formerly `Φ = hcat( (k.(sites) for k ∈ kernels)... )`\n    # Zygote-compatible:\n    N = length(kernels);\n    Φ_buff = Buffer( sites[1], S, N )\n    for (i, k) ∈ enumerate(kernels)\n        Φ_buff[:, i] = k.(sites)\n    end\n    Φ = copy(Φ_buff)\n\n    @show typeof(Φ)\n\n    # P-matrix, S × Q, formerly `transpose(hcat( (polys.(sites))... ) )`\n    Q = length(polys)\n    P_buff = Buffer( sites[1], S, Q )\n    for (i, s) ∈ enumerate(sites)\n        P_buff[i, :] = polys(s)\n    end\n    P = copy(P_buff)\n    @show typeof(P)\n\n    # system matrix A\n    Z = ST <: StaticArray ? @SMatrix(zeros(Int, Q, Q )) : zeros(Int, Q, Q)\n    A = vcat( [ Φ  P ], [ P' Z ] );\n\n    # build rhs\n    padding = VT <: StaticArray ? @SMatrix(zeros(Int, Q, n_out)) : zeros(Int, Q, n_out)\n    RHS = [\n        transpose( hcat( values... ) );\n        padding\n    ];\n    # solve system\n    coeff = A \\ RHS\n\n    # return w and λ\n    return coeff[1 : N, :], coeff[N+1 : end, :]\nend","category":"page"},{"location":"RBFModels/#The-Actual,-Usable-Constructor","page":"Main Module","title":"The Actual, Usable Constructor","text":"","category":"section"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"We want the user to be able to pass 1D data as scalars and use the following helpers:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"function ensure_vec_of_vecs( before :: AbstractVector{<:AbstractVector} )\n   return before\nend\n\nBase.vec( x :: T ) where T<:Real = SVector{1,T}(x)\nfunction ensure_vec_of_vecs( before :: AbstractVector{ <:Real } )\n    return( [vec(x) for x ∈ before ] )\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"Helpers to create kernel functions.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"\"Return array of `ShiftedKernel`s based functions in `φ_arr` with centers from `centers`.\"\nfunction make_kernels( φ_arr :: AbstractVector{<:RadialFunction}, centers :: VecOfVecs )\n    @assert length(φ_arr) == length(centers)\n    [ ShiftedKernel(φ, c) for (φ,c) ∈ zip( φ_arr, centers) ]\nend\n\"Return array of `ShiftedKernel`s based function `φ` with centers from `centers`.\"\nfunction make_kernels( φ :: RadialFunction, centers :: VecOfVecs )\n    [ ShiftedKernel(φ, c) for c ∈ centers ]\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"We use these methods to construct the RBFSum of a model. Note, the name is get_RBFSum to not run into infinite recursion with the default constructor.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"function get_RBFSum( kernels :: AbstractVector{<:ShiftedKernel}, weights :: AbstractMatrix{<:Real};\n        static_arrays :: Bool = true\n    )\n    num_outputs, num_centers = size(weights)\n\n    # Sized Matrix?\n    #@assert size(weights) == (num_centers, num_outputs) \"Weights must have dimensions $((num_centers, num_outputs)) instead of $(size(weights)).\"\n    make_static = !isa(weights, StaticArray) && num_centers * num_outputs < 100\n    wmat = begin\n        if static_arrays && make_static\n            SMatrix{num_outputs, num_centers}(weights)\n        else\n            weights\n        end\n    end\n\n    RBFSum( kernels, wmat )\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"We now have all ingredients for the basic outer constructor:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"@doc \"\"\"\n    RBFModel( features, labels, φ = Multiquadric(), poly_deg = 1; kwargs ... )\n\nConstruct a `RBFModel` from the feature vectors in `features` and\nthe corresponding labels in `lables`, where `φ` is a `RadialFunction` or a vector of\n`RadialFunction`s.\\n\nScalar data can be used, it is transformed internally. \\n\nStaticArrays can be used, e.g., `features :: Vector{<:SVector}`.\nProviding `SVector`s only might speed up the construction.\\n\nIf the degree of the polynomial tail, `poly_deg`, is too small it will be set to `cpd_order(φ)-1`.\n\nIf the RBF centers do not equal the the `features`, you can use the keyword argument `centers` to\npass a list of centers. If `φ` is a vector, then the length of `centers` and `φ` must be equal and\n`centers[i]` will be used in conjunction with `φ[i]` to build a `ShiftedKernel`. \\n\nIf `features` has 1D data, the output of the model will be a 1D-vector.\nIf it should be a scalar instead, set the keyword argument `vector_output` to `false`.\n\"\"\"\nfunction RBFModel(\n        features :: AbstractVector{ <:NumberOrVector },\n        labels :: AbstractVector{ <:NumberOrVector },\n        φ :: Union{RadialFunction,AbstractVector{<:RadialFunction}} = Multiquadric(),\n        poly_deg :: Int = 1;\n        centers :: AbstractVector{ <:NumberOrVector } = Vector{Float16}[],\n        interpolation_indices :: AbstractVector{ <: Int } = Int[],\n        vector_output :: Bool = true,\n        static_arrays :: Bool = true\n    )\n\n    # Basic Data integrity checks\n    @assert !isempty(features) \"Provide at least 1 feature vector.\"\n    @assert !isempty(labels) \"Provide at least 1 label vector.\"\n    num_vars = length(features[1])\n    num_outputs = length(labels[1])\n    @assert all( length(s) == num_vars for s ∈ features ) \"All features must have same dimension.\"\n    @assert all( length(v) == num_outputs for v ∈ labels ) \"All labels must have same dimension.\"\n\n    if !isempty( centers )\n        @assert all( length(s) == num_vars for s ∈ centers ) \"All centers must have dimension $(num_vars).\"\n    else\n        centers = features\n    end\n\n    sites = ensure_vec_of_vecs(features)\n    values = ensure_vec_of_vecs(labels)\n    centers = ensure_vec_of_vecs(centers)\n\n    num_centers = length(centers)","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"TODO benchmark whether array format makes some difference? centers <: SVector{<:SVector} or Vector{<:SVector} or Vector{<:Vector} makes a difference","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"    kernels = make_kernels(φ, centers)\n\n    poly_deg = max( poly_deg, cpd_order(φ) - 1 , -1 )\n    poly_basis_sys = canonical_basis( num_vars, poly_deg )\n\n    w, λ = coefficients( sites, values, kernels, poly_basis_sys )\n\n    # build output polynomials\n    poly_sum = PolySum( poly_basis_sys, transpose(λ) )\n\n    # build RBF system\n    rbf_sys = get_RBFSum(kernels, transpose(w); static_arrays)\n\n    # vector output? (dismiss user choice if labels are vectors)\n    vec_output = num_outputs == 1 ? vector_output : true\n\n    return RBFModel{vec_output, typeof(rbf_sys), typeof(poly_sum)}(\n         rbf_sys, poly_sum, num_vars, num_centers, num_outputs\n    )\nend\n\n### Special Constructors","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"We offer some specialized models (that simply wrap the main type).","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"struct RBFInterpolationModel\n    model :: RBFModel\nend\n(mod :: RBFInterpolationModel)(args...) = mod.model(args...)\n@forward RBFInterpolationModel.model grad, jac, jacT, auto_grad, auto_jac","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"The constructor is a tiny bit simpler and additional checks take place:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"\"\"\"\n    RBFInterpolationModel(features, labels, φ, poly_deg; kwargs… )\n\nBuild a model interpolating the feature-label pairs.\nDoes not accept `center` keyword argument.\n\"\"\"\nfunction RBFInterpolationModel(\n        features :: AbstractVector{ <:NumberOrVector },\n        labels :: AbstractVector{ <:NumberOrVector },\n        φ :: Union{RadialFunction,AbstractVector{<:RadialFunction}} = Multiquadric(),\n        poly_deg :: Int = 1;\n        vector_output :: Bool = true,\n        static_arrays :: Bool = true\n    )\n    @assert length(features) == length(labels) \"Provide as many features as labels!\"\n    mod = RBFModel(features, labels, φ, poly_deg; vector_output, static_arrays)\n    return RBFInterpolationModel( mod )\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"We want to provide a convenient alternative constructor for interpolation models so that the radial function can be defined by passing a Symbol or String.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"const SymbolToRadialConstructor = NamedTuple((\n    :gaussian => Gaussian,\n    :multiquadric => Multiquadric,\n    :inv_multiquadric => InverseMultiquadric,\n    :cubic => Cubic,\n    :thin_plate_spline => ThinPlateSpline\n))\n\nfunction RBFInterpolationModel(\n        features :: AbstractVector{ <:NumberOrVector },\n        labels :: AbstractVector{ <:NumberOrVector },\n        φ_symb :: Union{Symbol, String},\n        φ_args :: Union{Nothing, Tuple} = nothing,\n        poly_deg :: Int = 1; kwargs...\n    )\n    # which radial function to use?\n    radial_symb = Symbol( lowercase( string( φ_symb ) ) )\n    if !(radial_symb ∈ keys(SymbolToRadialConstructor))\n        @warn \"Radial Funtion $(radial_symb) not known, using Gaussian.\"\n        radial_symb = :gaussian\n    end\n\n    constructor = SymbolToRadialConstructor[radial_symb]\n    if φ_args isa Tuple\n        φ = constructor( φ_args... )\n    else\n        φ = constructor()\n    end\n\n    RBFInterpolationModel( features, labels, φ, poly_deg; kwargs... )\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"[wild_diss]: “Derivative-Free Optimization Algorithms For Computationally Expensive Functions”, Wild, 2009.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"[wendland]: “Scattered Data Approximation”, Wendland","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = RBFModels","category":"page"},{"location":"#RBFModels","page":"Home","title":"RBFModels","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [RBFModels]","category":"page"},{"location":"#Base.AbstractVector-Tuple{AbstractVector{var\"#s8\"} where var\"#s8\"<:Real}","page":"Home","title":"Base.AbstractVector","text":"Evaluate x   k₁(x)  k_N_c(x) at x.\n\n\n\n\n\n","category":"method"},{"location":"#RBFModels.Cubic","page":"Home","title":"RBFModels.Cubic","text":"Cubic( β = 3 ) <: RadialFunction\n\nA RadialFunction with \n\n    φ(ρ) = (-1)^ lceil β rceil 2  ρ^β\n\n\n\n\n\n","category":"type"},{"location":"#RBFModels.EmptyPolySystem","page":"Home","title":"RBFModels.EmptyPolySystem","text":"Drop-In Alternative to StaticPolynomials.PolynomialSystem when there are no outputs.\n\n\n\n\n\n","category":"type"},{"location":"#RBFModels.Gaussian","page":"Home","title":"RBFModels.Gaussian","text":"Gaussian( α = 1 ) <: RadialFunction\n\nA RadialFunction with \n\n    φ(ρ) = exp( - (α ρ)^2 )\n\n\n\n\n\n","category":"type"},{"location":"#RBFModels.InverseMultiquadric","page":"Home","title":"RBFModels.InverseMultiquadric","text":"InverseMultiquadric( α = 1, β = 1//2 ) <: RadialFunction\n\nA RadialFunction with \n\n    φ(ρ) = ( 1 + (αρ)^2 )^-β\n\n\n\n\n\n","category":"type"},{"location":"#RBFModels.Multiquadric","page":"Home","title":"RBFModels.Multiquadric","text":"Multiquadric( α = 1, β = 1//2 ) <: RadialFunction\n\nA RadialFunction with \n\n    φ(ρ) = (-1)^ lceil β rceil  ( 1 + (αρ)^2 )^β\n\n\n\n\n\n","category":"type"},{"location":"#RBFModels.RBFInterpolationModel","page":"Home","title":"RBFModels.RBFInterpolationModel","text":"RBFInterpolationModel(features, labels, φ, poly_deg; kwargs… )\n\nBuild a model interpolating the feature-label pairs. Does not accept center keyword argument.\n\n\n\n\n\n","category":"type"},{"location":"#RBFModels.RBFModel","page":"Home","title":"RBFModels.RBFModel","text":"RBFModel{V}\n\nV is true by default. It can be set to false only if the number  of outputs is 1. Then scalars are returned.\n\n\n\n\n\n","category":"type"},{"location":"#RBFModels.RBFModel-2","page":"Home","title":"RBFModels.RBFModel","text":"Evaluate model mod :: RBFModel at vector x.\n\n\n\n\n\n","category":"type"},{"location":"#RBFModels.RBFModel-3","page":"Home","title":"RBFModels.RBFModel","text":"RBFModel( features, labels, φ = Multiquadric(), poly_deg = 1; kwargs ... )\n\nConstruct a RBFModel from the feature vectors in features and  the corresponding labels in lables, where φ is a RadialFunction or a vector of  RadialFunctions.\n\nScalar data can be used, it is transformed internally. \n\nStaticArrays can be used, e.g., features :: Vector{<:SVector}.  Providing SVectors only might speed up the construction.\n\nIf the degree of the polynomial tail, poly_deg, is too small it will be set to cpd_order(φ)-1.\n\nIf the RBF centers do not equal the the features, you can use the keyword argument centers to pass a list of centers. If φ is a vector, then the length of centers and φ must be equal and  centers[i] will be used in conjunction with φ[i] to build a ShiftedKernel. \n\nIf features has 1D data, the output of the model will be a 1D-vector. If it should be a scalar instead, set the keyword argument vector_output to false.\n\n\n\n\n\n","category":"type"},{"location":"#RBFModels.RBFModel-Tuple{AbstractVector{var\"#s13\"} where var\"#s13\"<:Real, Int64}","page":"Home","title":"RBFModels.RBFModel","text":"Evaluate scalar output ℓ of model mod at vector x.\n\n\n\n\n\n","category":"method"},{"location":"#RBFModels.RBFSum-Tuple{AbstractVector{var\"#s13\"} where var\"#s13\"<:Real, Int64}","page":"Home","title":"RBFModels.RBFSum","text":"Evaluate output ℓ of RBF sum rbf::RBFSum\n\n\n\n\n\n","category":"method"},{"location":"#RBFModels.RBFSum-Tuple{AbstractVector{var\"#s13\"} where var\"#s13\"<:Real}","page":"Home","title":"RBFModels.RBFSum","text":"Evaluate rbf::RBFSum at x.\n\n\n\n\n\n","category":"method"},{"location":"#RBFModels.ShiftedKernel-Tuple{AbstractVector{var\"#s9\"} where var\"#s9\"<:Real}","page":"Home","title":"RBFModels.ShiftedKernel","text":"Evaluate kernel k at x - k.c.\n\n\n\n\n\n","category":"method"},{"location":"#RBFModels.ThinPlateSpline","page":"Home","title":"RBFModels.ThinPlateSpline","text":"ThinPlateSpline( k = 2 ) <: RadialFunction\n\nA RadialFunction with \n\n    φ(ρ) = (-1)^k+1 ρ^2k log(ρ)\n\n\n\n\n\n","category":"type"},{"location":"#RBFModels.auto_grad","page":"Home","title":"RBFModels.auto_grad","text":"Return gradient of output ℓ of model rbf at point x (using Zygote).\n\n\n\n\n\n","category":"function"},{"location":"#RBFModels.auto_jac-Tuple{RBFModel, AbstractVector{var\"#s13\"} where var\"#s13\"<:Real}","page":"Home","title":"RBFModels.auto_jac","text":"Return the jacobian of rbf at x (using Zygote).\n\n\n\n\n\n","category":"method"},{"location":"#RBFModels.coefficients-Union{Tuple{VT}, Tuple{ST}, Tuple{ST, VT, AbstractVector{var\"#s8\"} where var\"#s8\"<:RBFModels.ShiftedKernel, Union{RBFModels.EmptyPolySystem, StaticPolynomials.PolynomialSystem}}} where {ST<:(AbstractVector{T} where T), VT<:(AbstractVector{T} where T)}","page":"Home","title":"RBFModels.coefficients","text":"coefficients(sites, values, kernels, rad_funcs, polys )\n\nReturn the coefficient matrices w and λ for an rbf model  r(x) = Σ_i=1^N wᵢ φ(x - x^i) + Σ_j=1^M λᵢ pᵢ(x), where N is the length of rad_funcs (and centers) and M is the length of polys.\n\nThe arguments are \n\nan array of data sites sites with vector entries from ℝ^n.\nan array of data values values with vector entries from ℝ^k.\nan array of ShiftedKernels.\na PolynomialSystem or EmptyPolySystem (in case of deg = -1).\n\n\n\n\n\n","category":"method"},{"location":"#RBFModels.eval_and_auto_grad","page":"Home","title":"RBFModels.eval_and_auto_grad","text":"Evaluate output ℓ of the model and return the gradient.\n\n\n\n\n\n","category":"function"},{"location":"#RBFModels.eval_and_auto_jac-Tuple{RBFModel, AbstractVector{var\"#s10\"} where var\"#s10\"<:Real}","page":"Home","title":"RBFModels.eval_and_auto_jac","text":"Evaluate the model and return the jacobian at the same time.\n\n\n\n\n\n","category":"method"},{"location":"#RBFModels.eval_at_dist-Tuple{AbstractVector{var\"#s12\"} where var\"#s12\"<:RBFModels.ShiftedKernel, AbstractVector{var\"#s13\"} where var\"#s13\"<:Real}","page":"Home","title":"RBFModels.eval_at_dist","text":"Evaluate x   k₁(x)  k_N_c(x), provided the distances  ρ_1(x)  ρ_N_c(x) .\n\n\n\n\n\n","category":"method"},{"location":"#RBFModels.eval_at_dist-Tuple{RBFModels.ShiftedKernel, Real}","page":"Home","title":"RBFModels.eval_at_dist","text":"Evaluate k.φ for distance ρ where ρ should equal x - k.c for the argument x.\n\n\n\n\n\n","category":"method"},{"location":"#RBFModels.make_kernels-Tuple{AbstractVector{var\"#s12\"} where var\"#s12\"<:RBFModels.RadialFunction, AbstractVector{var\"#s14\"} where var\"#s14\"<:(AbstractVector{T} where T)}","page":"Home","title":"RBFModels.make_kernels","text":"Return array of ShiftedKernels based functions in φ_arr with centers from centers.\n\n\n\n\n\n","category":"method"},{"location":"#RBFModels.make_kernels-Tuple{RBFModels.RadialFunction, AbstractVector{var\"#s14\"} where var\"#s14\"<:(AbstractVector{T} where T)}","page":"Home","title":"RBFModels.make_kernels","text":"Return array of ShiftedKernels based function φ with centers from centers.\n\n\n\n\n\n","category":"method"},{"location":"#RBFModels.non_negative_solutions-Tuple{Int64, Int64}","page":"Home","title":"RBFModels.non_negative_solutions","text":"non_negative_solutions( d :: Int, n :: Int)\n\nReturn a matrix with columns that correspond to solution vectors  x_1  x_n to the equation x_1 +  + x_n = d, where the variables are non-negative integers.\n\n\n\n\n\n","category":"method"},{"location":"#StaticPolynomials.evaluate-Union{Tuple{Nvars}, Tuple{RBFModels.EmptyPolySystem{Nvars}, StaticArrays.StaticVector{N, T} where {N, T}}} where Nvars","page":"Home","title":"StaticPolynomials.evaluate","text":"Evaluate for sized input.\n\n\n\n\n\n","category":"method"},{"location":"#StaticPolynomials.evaluate-Union{Tuple{R}, Tuple{RBFModels.EmptyPolySystem, Union{Vector{R}, R}}} where R<:Real","page":"Home","title":"StaticPolynomials.evaluate","text":"Evaluate for usual vector input. (Scalar input also supported, there are no checks)\n\n\n\n\n\n","category":"method"},{"location":"#ZygoteRules._pullback-Tuple{Zygote.Context, typeof(RBFModels.canonical_basis), Vararg{Any, N} where N}","page":"Home","title":"ZygoteRules._pullback","text":"canonical_basis( n:: Int, d :: Int ) :: Union{PolynomialSystem, EmptyPolySystem}\n\nReturn the canonical basis of the space of n-variate  polynomials of degree at most d.\n\n\n\n\n\n","category":"method"}]
}
