var documenterSearchIndex = {"docs":
[{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"EditURL = \"https://github.com/manuelbb-upb/RadialBasisFunctionModels.jl/blob/master/src/RadialBasisFunctionModels.jl\"","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"using Base: NamedTuple, promote_eltype\n\nexport RBFInterpolator\nexport RBFMachine, fit!, add_data!\n\nexport auto_grad, auto_jac, grad, jac, eval_and_auto_grad\nexport eval_and_auto_jac, eval_and_grad, eval_and_jac","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"Dependencies of this module:","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"using StaticPolynomials\nusing ThreadSafeDicts\nusing Memoization: @memoize\nusing StaticArrays\nusing LinearAlgebra: norm\nusing Lazy: @forward\nusing Parameters: @with_kw\n\nfor V in [:SizedVector, :MVector]\nend\n\nimport Zygote as Zyg\nusing Zygote: Buffer","category":"page"},{"location":"RadialBasisFunctionModels/#Radial-Basis-Function-Models","page":"Main Module","title":"Radial Basis Function Models","text":"","category":"section"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"The module RadialBasisFunctionModels provides utilities to work with radial basis function [RBF] models. Given N data sites X =  x^1  x^N   ℝ^n and values Y =  y^1  y^N   ℝ, an interpolating RBF model rcolon ℝ^n  ℝ has the form","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"r(x) = sum_i=1^N w_i φ(  x - x^i _2 ) + p(x)","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"where p is a multivariate polynomial. The radial function φcolon 0 ) to ℝ defines the RBF and we can solve for the coefficients w by solving the interpolation system","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"beginequation\nr( x^i ) stackrel= y^i quad textfor all i=1N\nlabeleqncoeff_basic\nendequation","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"note: Note\nSee the section about Getting the Coefficients for how we actually solve the equation system.","category":"page"},{"location":"RadialBasisFunctionModels/#Radial-Basis-Function-Sum.","page":"Main Module","title":"Radial Basis Function Sum.","text":"","category":"section"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"The function k() = φ(_2) is radially symmetric around the origin. k is called the kernel of an RBF.","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"We define an abstract super type for radial functions:","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"abstract type RadialFunction <: Function end","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"Each Type that inherits from RadialFunction should implement an evaluation method. It takes the radius/distance ρ = ρ(x) =  x - x^i  from x to a specific center x^i.","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"(φ :: RadialFunction )( ρ :: Real ) :: Real = Nothing;\nnothing #hide","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"We also need the so called order of conditional positive definiteness:","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"cpd_order( φ :: RadialFunction) :: Int = nothing;\nnothing #hide","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"The derivative can also be specified. It defaults to","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"df( φ :: RadialFunction, ρ ) = Zyg.gradient( φ, ρ )[1]","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"The file radial_funcs.jl contains various radial function implementations.","category":"page"},{"location":"RadialBasisFunctionModels/#Some-Radial-Functions","page":"Main Module","title":"Some Radial Functions","text":"","category":"section"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"The Gaussian is defined by φ(ρ) = exp left( - (αρ)^2 right), where α is a shape parameter to fine-tune the function.","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"\"\"\"\n    Gaussian( α = 1 ) <: RadialFunction\n\nA `RadialFunction` with\n```math\n    φ(ρ) = \\\\exp( - (α ρ)^2 ).\n```\n\"\"\"\n@with_kw struct Gaussian{R<:Real} <: RadialFunction\n    α :: R = 1\n    @assert α > 0 \"The shape parameter `α` must be positive.\"\nend\n\nfunction ( φ :: Gaussian )( ρ :: Real )\n    exp( - (φ.α * ρ)^2 )\nend\n\ncpd_order( :: Gaussian ) = 0\ndf(φ :: Gaussian, ρ :: Real) = - 2 * φ.α^2 * ρ * φ( ρ )","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"The Multiquadric is φ(ρ) = - sqrt 1 + (αρ)^2  and also has a positive shape parameter. We can actually generalize it to the following form:","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"\"\"\"\n    Multiquadric( α = 1, β = 1//2 ) <: RadialFunction\n\nA `RadialFunction` with\n```math\n    φ(ρ) = (-1)^{ \\\\lceil β \\\\rceil } ( 1 + (αρ)^2 )^β\n```\n\"\"\"\n@with_kw struct Multiquadric{R<:Real,S<:Real} <: RadialFunction\n    α :: R  = 1     # shape parameter\n    β :: S  = 1//2  # exponent\n\n    @assert α > 0 \"The shape parameter `α` must be positive.\"\n    @assert β % 1 != 0 \"The exponent must not be an integer.\"\n    @assert β > 0 \"The exponent must be positive.\"\nend\n\nfunction ( φ :: Multiquadric )( ρ :: Real )\n    (-1)^(ceil(Int, φ.β)) * ( 1 + (φ.α * ρ)^2 )^φ.β\nend\n\ncpd_order( φ :: Multiquadric ) = ceil( Int, φ.β )\ndf(φ :: Multiquadric, ρ :: Real ) = (-1)^(ceil(Int, φ.β)) * 2 * φ.α * φ.β * ρ * ( 1 + (φ.α * ρ)^2 )^(φ.β - 1)","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"Related is the Inverse Multiquadric φ(ρ) = (1+(αρ)^2)^-β:","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"\"\"\"\n    InverseMultiquadric( α = 1, β = 1//2 ) <: RadialFunction\n\nA `RadialFunction` with\n```math\n    φ(ρ) = ( 1 + (αρ)^2 )^{-β}\n```\n\"\"\"\n@with_kw struct InverseMultiquadric{R<:Real,S<:Real} <: RadialFunction\n    α :: R  = 1\n    β :: S  = 1//2\n\n    @assert α > 0 \"The shape parameter `α` must be positive.\"\n    @assert β > 0 \"The exponent must be positive.\"\nend\n\nfunction ( φ :: InverseMultiquadric )( ρ :: Real )\n   ( 1 + (φ.α * ρ)^2 )^(-φ.β)\nend\n\ncpd_order( :: InverseMultiquadric ) = 0\ndf(φ :: InverseMultiquadric, ρ :: Real ) = - 2 * φ.α^2 * φ.β * ρ * ( 1 + (φ.α * ρ)^2 )^(-φ.β - 1)","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"The Cubic is φ(ρ) = ρ^3. It can also be generalized:","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"\"\"\"\n    Cubic( β = 3 ) <: RadialFunction\n\nA `RadialFunction` with\n```math\n    φ(ρ) = (-1)^{ \\\\lceil β \\\\rceil /2 } ρ^β\n```\n\"\"\"\n@with_kw struct Cubic <: RadialFunction\n    β :: Int = 3\n\n    @assert β > 0 \"The exponent `β` must be positive.\"\n    @assert β % 2 != 0 \"The exponent `β` must not be an even number.\"\nend\n\nfunction ( φ :: Cubic )( ρ :: Real )\n    (-1)^ceil(Int, φ.β/2 ) * ρ^φ.β\nend\n\ncpd_order( φ :: Cubic ) = ceil( Int, φ.β/2 )\ndf(φ :: Cubic, ρ :: Real ) = (-1)^(ceil(Int, φ.β/2)) * φ.β * ρ^(φ.β - 1)","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"The thin plate spline is usually defined via φ(ρ) = ρ^2 log( ρ ). We provide a generalized version, which defaults to φ(ρ) = - ρ^4 log( ρ ).","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"\"\"\"\n    ThinPlateSpline( k = 2 ) <: RadialFunction\n\nA `RadialFunction` with\n```math\n    φ(ρ) = (-1)^{k+1} ρ^{2k} \\\\log(ρ)\n```\n\"\"\"\n@with_kw struct ThinPlateSpline <: RadialFunction\n    k :: Int = 2\n\n    @assert k > 0 && k % 1 == 0 \"The parameter `k` must be a positive integer.\"\nend\n\nfunction (φ :: ThinPlateSpline )( ρ :: T ) where T<:Real\n    ρ == 0 ? zero(T) : (-1)^(φ.k+1) * ρ^(2*φ.k) * log( ρ )\nend\n\ncpd_order( φ :: ThinPlateSpline ) = φ.k + 1\ndf(φ :: ThinPlateSpline, ρ :: Real ) = ρ == 0 ? 0 : (-1)^(φ.k+1) * ρ^(2*φ.k - 1) * ( 2 * φ.k * log(ρ) + 1)","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"note: Note\nThe thin plate spline with k = 1 is not differentiable at ρ=0 but we define the derivative as 0, which results in a continuous extension.","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"From an RadialFunction and a vector we can define a shifted kernel function.","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"const NumberOrVector = Union{<:Real, AbstractVector{<:Real}}\n\nstruct ShiftedKernel{RT <: RadialFunction, CT <: AbstractVector{<:Real}} <: Function\n    φ :: RT\n    c :: CT\nend\n\nnorm2( vec ) = norm(vec, 2)\n\n\"Evaluate kernel `k` at `x - k.c`.\"\nfunction (k::ShiftedKernel)( x :: AbstractVector{<:Real} )\n    return k.φ( norm2( x .- k.c ) )\nend","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"A vector of N kernels is a mapping ℝ^n  ℝ^N  x   k₁(x)  k_N(x).","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"_eval_vec_of_kernels( K, x ) = [k(x) for k ∈ K]\n\n\"Evaluate ``x ↦ [ k₁(x), …, k_{N_c}(x)]`` at `x`.\"\n( K::AbstractVector{<:ShiftedKernel})( x ) = _eval_vec_of_kernels( K, x )","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"Suppose, we have calculated the distances x - x^i beforehand. We can save redundant effort by passing them to the radial functions of the kernels.","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"\"Evaluate `k.φ` for distance `ρ` where `ρ` should equal `x - k.c` for the argument `x`.\"\neval_at_dist( k :: ShiftedKernel , ρ :: Real ) = k.φ(ρ)\n\n\"Evaluate ``x ↦ [ k₁(x), …, k_{N_c}(x)]``, provided the distances ``[ ρ_1(x), …, ρ_{N_c}(x) ]``.\"\nfunction eval_at_dist( K::AbstractVector{<:ShiftedKernel}, dists :: AbstractVector{<:Real})\n    [ eval_at_dist(k,ρ) for (k,ρ) ∈ zip(K,dists) ]\nend","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"Provided we have solved the interpolation system, the weights for the radial basis function part of r are w, where w is a vector of length N_c or a matrix in ℝ^N_c times k where k is the number of outputs. We treat the general case kge 1 and always assume w to be a matrix.","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"struct RBFSum{\n    KT <: AbstractVector{<:ShiftedKernel},\n    WT <: AbstractMatrix{<:Real}\n}\n    kernels :: KT\n    weights :: WT # can be a normal matrix or a SMatrix\n\n    num_outputs :: Int\nend","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"Make it display nicely:","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"function Base.show( io :: IO, rbf :: RBFSum{KT,WT} ) where {KT, WT}\n    compact = get(io, :compact, false)\n    if compact\n        print(io, \"RBFSum{$(KT), $(WT)}\")\n    else\n        n_out, n_kernels = size(rbf.weights)\n        print(io, \"RBFSum\\n\")\n        print(io, \"* with $(n_kernels) kernels in an array of type $(KT)\\n\")\n        print(io, \"* and a $(n_kernels)×$(n_out) weight matrix of type $(WT).\")\n    end\nend","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"We can easily evaluate the ℓ-th output of the RBFPart:","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"@doc \"Evaluate outut `ℓ` of RBF sum `rbf::RBFSum`\"\nfunction (rbf :: RBFSum)(x :: AbstractVector, ℓ :: Int)\n    return (rbf.weights[ℓ,:]'rbf.kernels(x))[1]\nend","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"The overall output is a vector, and we also get it via matrix multiplication.","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"_eval_rbfsum(rbf::RBFSum, x ) = rbf.weights*rbf.kernels(x)\n\"Evaluate `rbf::RBFSum` at `x`.\"\n(rbf :: RBFSum)( x :: AbstractVector ) = _eval_rbfsum(rbf, x)","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"We want to return the right type and use _type_guard:","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"_type_guard( x , :: Type{<:Vector}, :: Int ) = convert( Vector, x)\nfor V in [:SVector, :MVector, :SizedVector ]\n    @eval _type_guard( x, ::Type{ <: $V }, n_out :: Int ) = convert($V{ n_out }, x)\nend\n\n(rbf :: RBFSum)( x :: Vector ) = _type_guard( _eval_rbfsum(rbf, x), Vector, rbf.num_outputs )\nfunction (rbf :: RBFSum)( x :: T ) where T<:Union{SVector,MVector,SizedVector}\n    return _type_guard( _eval_rbfsum(rbf, x), T, rbf.num_outputs )\nend","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"As before, we allow to pass precalculated distance vectors:","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"function eval_at_dist( rbf::RBFSum, dists :: AbstractVector{<:Real}, ℓ :: Int )\n   rbf.weights[ℓ,:]'eval_at_dist( rbf.kernels, dists )\nend\n\nfunction eval_at_dist( rbf :: RBFSum, dists :: AbstractVector{<:Real})\n   vec(rbf.weights*eval_at_dist(rbf.kernels, dists ))\nend","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"For the PolynomialTail do something similar and use a StaticPolynomials.PolynomialSystem with a weight matrix.","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"If the polynomial degree is < 0, we use an EmptyPolySystem:","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"\"Drop-In Alternative to `StaticPolynomials.PolynomialSystem` when there are no outputs.\"\nstruct EmptyPolySystem{Nvars} end\nBase.length(::EmptyPolySystem) = 0\nStaticPolynomials.npolynomials(::EmptyPolySystem) = 0\n\n\"Evaluate for usual vector input. (Scalar input also supported, there are no checks)\"\nStaticPolynomials.evaluate(:: EmptyPolySystem, :: Union{R, Vector{R}}) where R<:Real = Int[]\n\"Evaluate for sized input.\"\nStaticPolynomials.evaluate(:: EmptyPolySystem{Nvars}, :: StaticVector ) where {Nvars} = SVector{0,Int}()\n(p :: EmptyPolySystem)( x :: NumberOrVector) = evaluate(p, x)\n\nfunction StaticPolynomials.jacobian( :: EmptyPolySystem{Nvars}, args... ) where Nvars\n    Matrix{Int}(undef, 0, Nvars )\nend\n\nfunction StaticPolynomials.evaluate_and_jacobian( p :: EmptyPolySystem, args ... )\n    return p(args...), jacobian(p, args...)\nend","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"This allows for the PolySum. polys evaluates the polynomial basis and weights are determined during training/fitting.","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"struct PolySum{\n        PS <: Union{EmptyPolySystem, PolynomialSystem},\n        WT <: AbstractMatrix\n    }\n    polys :: PS\n    weights :: WT       # n_out × n_polys matrix\n    num_outputs :: Int\n\n    function PolySum( polys :: PS, weights :: WT) where{PS, WT}\n        n_out, n_polys = size(weights)\n        @assert npolynomials(polys) == n_polys \"Number of polynomials does not macth.\"\n        new{PS,WT}(polys, weights, n_out)\n    end\nend\n\neval_psum( p :: PolySum, x ) = p.weights * p.polys(x)\n(p :: PolySum)(x :: AbstractVector ) = eval_psum( p, x )\n(p :: PolySum)(x :: Vector ) = _type_guard(eval_psum(p,x), Vector, p.num_outputs )\n(p :: PolySum)(x :: T) where T<:Union{SVector,MVector,SizedVector} = _type_guard( eval_psum(p,x), T, p.num_outputs)\n\n(p :: PolySum)(x,ℓ::Int) = (p.weights[ℓ,:]'p.polys(x))[end]","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"We now have all ingredients to define the model type.","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"\"\"\"\n    RBFModel{V}\n\n* `V` is `true` by default. It can be set to `false` only if the number\n  of outputs is 1. Then scalars are returned.\n\n\"\"\"\nstruct RBFModel{V,\n        RS <: RBFSum,\n        PS <: PolySum }\n    rbf :: RS\n    psum :: PS\n\n    # Information fields\n    num_vars :: Int\n    num_outputs :: Int\n    num_centers :: Int\nend","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"We want a model to be displayed in a sensible way:","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"function Base.show( io :: IO, mod :: RBFModel{V,RS,PS} ) where {V,RS,PS}\n    compact = get(io, :compact, false)\n    if compact\n        print(io, \"$(mod.num_vars)D$(mod.num_outputs)D-RBFModel{$(V)}\")\n    else\n        print(io, \"RBFModel{$(V),$(RS),$(PS)}\\n\")\n        if V\n            print(io, \"\\twith vector output \")\n        else\n            print(io, \" with scalar output \")\n        end\n        print(io, \"and $(mod.num_centers) centers, \")\n        print(io, \"mapping from ℝ^$(mod.num_vars) to ℝ^$(mod.num_outputs).\")\n    end\nend","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"Evaluation is easy. We accept an additional ::Nothing argument that does nothing for now, but saves some typing later.","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"function vec_eval(mod :: RBFModel, x :: AbstractVector{<:Real}, :: Nothing)\n    return mod.rbf(x) .+ mod.psum( x )\nend\n\nfunction scalar_eval(mod :: RBFModel, x :: AbstractVector{<:Real}, :: Nothing )\n    return (mod.rbf(x) + mod.psum( x ))[1]\nend\n\n# @doc \"Evaluate model `mod :: RBFModel` at vector `x`.\"\n( mod :: RBFModel{true, RS, PS} where {RS,PS} )(x :: AbstractVector{<:Real}, ℓ :: Nothing = nothing ) = vec_eval(mod,x,ℓ)\n( mod :: RBFModel{false, RS, PS} where {RS,PS} )(x :: AbstractVector{<:Real}, ℓ :: Nothing = nothing ) = scalar_eval(mod,x,ℓ)\n\n\"Evaluate scalar output `ℓ` of model `mod` at vector `x`.\"\nfunction (mod :: RBFModel)( x :: AbstractVector{<:Real}, ℓ :: Int)\n    return mod.rbf(x, ℓ) + mod.psum( x, ℓ )\nend\n\n# scalar input\nconst NothInt = Union{Nothing,Int}\n\nfunction (mod :: RBFModel)(x :: Real, ℓ :: NothInt = nothing )\n    @assert mod.num_vars == 1 \"The model has more than 1 inputs. Provide a vector `x`, not a number.\"\n    mod( [x,], ℓ)\nend","category":"page"},{"location":"RadialBasisFunctionModels/#Derivatives","page":"Main Module","title":"Derivatives","text":"","category":"section"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"The easiest way to provide derivatives is via Automatic Differentiation. We have imported Zygote as Zyg. For automatic differentiation we need custom adjoints for some StaticArrays:","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"Zyg.@adjoint (T::Type{<:SizedMatrix})(x::AbstractMatrix) = T(x), dv -> (nothing, dv)\nZyg.@adjoint (T::Type{<:SizedVector})(x::AbstractVector) = T(x), dv -> (nothing, dv)\nZyg.@adjoint (T::Type{<:SArray})(x::AbstractArray) = T(x), dv -> (nothing, dv)","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"This allows us to define the following methods:","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"\"Return the jacobian of `rbf` at `x` (using Zygote).\"\nfunction auto_jac( rbf :: RBFModel, x :: AbstractVector{<:Real} )\n    Zyg.jacobian( rbf, x )[1]\nend\n\n\"Evaluate the model and return the jacobian at the same time.\"\nfunction eval_and_auto_jac( rbf :: RBFModel, x :: AbstractVector{<:Real} )\n    y, back = Zyg._pullback( rbf, x )\n\n    T = eltype(y)   # TODO does this make sense?\n    n = length(y)\n    jac = zeros(T, n, length(x) )\n    for i = 1 : length(x)\n        e = [ zeros(T, i -1 ); T(1); zeros(T, n - i )  ]\n        jac[i, :] .= back(e)[2]\n    end\n\n    return y, jac\nend\n\n\"Return gradient of output `ℓ` of model `rbf` at point `x` (using Zygote).\"\nfunction auto_grad( rbf :: RBFModel, x :: AbstractVector{<:Real}, ℓ :: Int = 1)\n    Zyg.gradient( χ -> rbf(χ, ℓ), x )[1]\nend\n\n\"Evaluate output `ℓ` of the model and return the gradient.\"\nfunction eval_and_auto_grad( rbf :: RBFModel, x :: AbstractVector{<:Real}, ℓ :: Int = 1 )\n    y, back = Zyg._pullback( χ -> rbf(χ, ℓ)[end], x)\n\n    grad = back( one(y) )[2]\n    return y, grad\nend","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"note: Note\nWe need at least ChainRules@v.0.7.64 to have auto_grad etc. work for StaticArrays, see this issue.","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"But we don't need Zygote, because we can derive the gradients ourselves. Assume that φ is two times continuously differentiable. \nWhat is the gradient of a scalar RBF model? Using the chain rule and ξ = x - x^j we get","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"dfracξ_i left( φ( ξ ) right)\n=\nφprime (  ξ  ) cdot\ndfracξ_i (  ξ  )\n=\nφprime (  ξ  ) cdot\ndfracξ_iξ","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"The right term is always bounded, but not well defined for ξ = 0 (see [wild_diss] for details). \nThat is why we require φ(0) stackrel= 0. \nWe have dfracx_i ξ(x) = 1 and thus","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"r(x) = sum_i=1^N fracw_i φprime(  x - x^i  ) x - x^i  (x - x^i) + p(x)","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"We can then implement the formula from above. For a fixed center x^i let o be the distance vector x - x^i and let ρ be the norm ρ = o =  x- x^i . Then, the gradient of a single kernel is:","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"function grad( k :: ShiftedKernel, o :: AbstractVector{<:Real}, ρ :: Real )\n    ρ == 0 ? zero(k.c) : (df( k.φ, ρ )/ρ) .* o\nend","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"In terms of x:","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"function grad( k :: ShiftedKernel, x :: AbstractVector{<:Real} )\n    o = x - k.c     # offset vector\n    ρ = norm2( o )  # distance\n    return grad( k, o, ρ )\nend","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"The jacobian of a vector of kernels follows suit:","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"function jacT( K :: AbstractVector{<:ShiftedKernel}, x :: AbstractVector{<:Real})\n    hcat( ( grad(k,x) for k ∈ K )... )\nend\n# precalculated offsets and distances, 1 per kernel\nfunction jacT( K :: AbstractVector{<:ShiftedKernel}, offsets :: AbstractVector{<:AbstractVector}, dists :: AbstractVector{<:Real} )\n    hcat( ( grad(k,o,ρ) for (k,o,ρ) ∈ zip(K,offsets,dists) )... )\nend\njac( K :: AbstractVector{<:ShiftedKernel}, args... ) = transpose( jacT(K, args...) )","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"Hence, the gradients of an RBFSum are easy:","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"function grad( rbf :: RBFSum, x :: AbstractVector{<:Real}, ℓ :: Int = 1 )\n    #vec( jacT( rbf.kernels, x) * rbf.weights[:,ℓ] )\n    vec( rbf.weights[ℓ,:]'jac( rbf.kernels, x ) )\nend\n\nfunction grad( rbf :: RBFSum, offsets :: AbstractVector{<:AbstractVector}, dists :: AbstractVector{<:Real}, ℓ :: Int)\n    return vec( rbf.weights[ℓ,:]'jac( rbf.kernels, offsets, dists ) )\nend","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"The grad method looks very similar for the PolySum. We obtain the jacobian of the polynomial basis system via PolynomialSystem.jacobian.","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"function grad( psum :: PolySum, x :: AbstractVector{<:Real} , ℓ :: Int = 1)\n    return vec( psum.weights[ℓ,:]'jacobian( psum.polys, x ))\nend","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"For the RBFModel we simply combine both methods:","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"function _grad( mod :: RBFModel, x :: AbstractVector{<:Real}, ℓ :: Int = 1 )\n    return grad(mod.rbf, x, ℓ) + grad( mod.psum, x, ℓ )\nend\n\nfunction grad( mod :: RBFModel, x :: AbstractVector{<:Real}, ℓ :: Int = 1 )\n    return _grad(mod, x, ℓ)\nend\n\ngrad( mod :: RBFModel, x :: Vector{<:Real}, ℓ :: Int = 1 ) = _type_guard( _grad(mod, x, ℓ), Vector, mod.num_vars )\nfunction grad( mod :: RBFModel, x :: T, ℓ :: Int = 1 ) where T <: Union{SVector, MVector, SizedVector}\n    return _type_guard( _grad(mod, x, ℓ), T, mod.num_vars )\nend","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"We can exploit our custom evaluation methods for \"distances\":","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"function _offsets_and_dists( rbf :: RBFSum, x :: AbstractVector{<:Real} )\n    offsets = [ x - k.c for k ∈ rbf.kernels ]\n    dists = norm2.(offsets)\n    return offsets, dists\nend\n\nfunction eval_and_grad( rbf :: RBFSum, offsets :: AbstractVector{<:AbstractVector}, dists :: AbstractVector{<:Real}, ℓ :: Int)\n    return eval_at_dist( rbf, dists, ℓ ), grad( rbf, offsets, dists, ℓ)\nend\n\nfunction eval_and_grad( rbf :: RBFSum, x :: AbstractVector{<:Real}, ℓ :: Int = 1)\n    offsets, dists = _offsets_and_dists(rbf, x)\n    return eval_and_grad( rbf, offsets, dists, ℓ)\nend","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"For the PolySum we use evaluate_and_jacobian.","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"function eval_and_grad( psum :: PolySum, x :: AbstractVector{<:Real}, ℓ :: Int = 1)\n    res_p, J_p = evaluate_and_jacobian( psum.polys, x )\n    return (psum.weights[ℓ,:]'res_p)[1], vec(psum.weights[ℓ,:]'J_p)\nend","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"Combine for RBFModel:","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"function eval_and_grad( mod :: RBFModel, x :: AbstractVector{<:Real}, ℓ :: Int = 1 )\n    res_rbf, g_rbf = eval_and_grad( mod.rbf, x, ℓ )\n    res_polys, g_polys = eval_and_grad( mod.psum, x, ℓ )\n    return res_rbf .+ res_polys, g_rbf .+ g_polys\nend","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"For the jacobian, we use the same trick to save evaluations.","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"function jac( rbf :: RBFSum, x :: AbstractVector{<:Real} )\n    offsets, dists = _offsets_and_dists(rbf, x)\n    rbf.weights * jac( rbf.kernels, offsets, dists )\nend\njacT(rbf :: RBFSum, args... ) = transpose( jac(rbf, args...) )\n\nfunction jac( psum :: PolySum, x :: AbstractVector{<:Real} )\n    psum.weights * jacobian( psum.polys, x )\nend\n\nfunction _jac( mod :: RBFModel, x :: AbstractVector{<:Real} )\n    jac( mod.rbf, x ) + jac( mod.psum, x)\nend\n\njac( mod :: RBFModel, x :: AbstractMatrix{<:Real} ) = _jac(mod,x)\njac( mod :: RBFModel, x :: Vector{<:Real}) = convert(Matrix, _jac(mod,x))\njac( mod :: RBFModel, x :: SVector{<:Real}) = convert( SMatrix{mod.num_outputs, mod_nmu_vars}, _jac(mod,x) )\njac( mod :: RBFModel, x :: MVector{<:Real}) = convert( MMatrix{mod.num_outputs, mod_nmu_vars}, _jac(mod,x) )\njac( mod :: RBFModel, x :: SizedVector{<:Real}) = convert( SizedMatrix{mod.num_outputs, mod_nmu_vars}, _jac(mod,x) )","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"As before, define an \"evaluate-and-jacobian\" function that saves evaluations:","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"function eval_and_jac( rbf :: RBFSum, x :: AbstractVector{<:Real} )\n    offsets, dists = _offsets_and_dists(rbf, x)\n    res = eval_at_dist( rbf, dists )\n    J = rbf.weights * jac( rbf.kernels, offsets, dists )\n    return res, J\nend\n\nfunction eval_and_jac( psum :: PolySum, x :: AbstractVector{<:Real} )\n    res_p, J_p = evaluate_and_jacobian( psum.polys, x )\n    return vec( psum.weights * res_p ), psum.weights * J_p\nend\n\nfunction eval_and_jac( mod :: RBFModel, x :: AbstractVector{<:Real} )\n    res_rbf, J_rbf = eval_and_jac( mod.rbf, x )\n    res_polys, J_polys = eval_and_jac( mod.psum, x)\n    return res_rbf + res_polys, J_rbf + J_polys\nend\n\n# TODO type stable eval_and_grad and eval_and_jac ?","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"note: Note\nHessians are not yet implemented.","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"For the Hessian Hr colon ℝ^n to ℝ^ntimes n we need the gradients of the component functions","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"    ψ_j(ξ) = frac φ( left ξ right )ξ ξ_j","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"Suppose ξ  0. First, using the product rule, we have","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"   dfracξ_i\n   left(\n   frac φ( left ξ right )ξ ξ_j\n   right) =\n   ξ_j\n   dfracξ_i\n   left(\n   frac φ( left ξ right )ξ\n   right)\n   +\n   frac φ( left ξ right )ξ\n   dfracξ_i\n   ξ_j","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"The last term is easy because of","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"fracξ_i ξ_j\n=\nbegincases\n    1  textif i = j\n    0  textelse\nendcases","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"For the first term we find","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"   dfracξ_i\n   left(\n     frac φ( left ξ right )\n      ξ\n   right)\n   =\n   frac\n       φleft(left ξ rightright) _i ξ\n       - ξ _i φleft( left ξ rightright)\n    \n        ξ^2\n    \n    =\n    frac\n        dfracφ(ξ)ξ ξ_i - ξφ(ξ)dfracξ_iξ\n    ξ^2","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"Hence, the gradient of ψ_j is","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"    ψ_j(ξ)\n    =\n    left( fracφ(ξ)ξ^3\n    -\n    fracφ(ξ)ξ^2 right) cdot ξ\n    -fracφ(ξ)ξ e^j","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"where e^j  ℝ^n is all zeros, except e^j_j = 1. For ξ = 0 the first term vanishes due to L'Hôpital's rule:","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"ψ_j(0) = φ(0) e^j","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"This file is included from within RadialBasisFunctionModels.jl #src","category":"page"},{"location":"RadialBasisFunctionModels/#Getting-the-Coefficients","page":"Main Module","title":"Getting the Coefficients","text":"","category":"section"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"const VecOfVecs{T} = AbstractVector{<:AbstractVector}","category":"page"},{"location":"RadialBasisFunctionModels/#Polynomial-Basis","page":"Main Module","title":"Polynomial Basis","text":"","category":"section"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"Any constructor of an RBFModel must solve for the coefficients in eqrefeqncoeff_basic. To build the equation system, we need a basis p_j_1 le j le Q of Π_d(ℝ^n). For the interpolation system to be solvable we have to choose the right polynomial space for p. Basically, if the RBF Kernel (or the radial function) is conditionally positive definite of order D we have to find a polynomial p with deg p ge D-1.[wendland] If the kernel is CPD of order D=0 we do not have to add an polynomial and can interpolate arbitrary (distinct) data points. \n The canonical basis is x_1^α_1 x_2^α_2  x_n^α_n with α_i  0 and Σ_i α_i  d. For bard le d we can recursively get the non-negative integer solutions for Σ_i α_i = bard with the following function:","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"@doc \"\"\"\n    non_negative_solutions( d :: Int, n :: Int)\n\nReturn a matrix with columns that correspond to solution vectors\n``[x_1, …, x_n]`` to the equation ``x_1 + … + x_n = d``,\nwhere the variables are non-negative integers.\n\"\"\"\nfunction non_negative_solutions( d :: Int, n :: Int )\n    if n == 1\n        return fill(d,1,1)\n    else\n        num_sols = binomial( d + n - 1, n - 1)\n        sol_matrix = Matrix{Int}(undef, n, num_sols)\n        j = 1\n        for i = 0 : d\n            # find all solutions of length `n-1` that sum to `i`\n            # if we add `d-i` to each column, then each column\n            # has `n` elements and sums to `d`\n            padded_shorter_solutions = vcat( d-i, non_negative_solutions(i, n-1) )\n            num_shorter_sols = size( padded_shorter_solutions, 2 )\n            sol_matrix[:, j : j + num_shorter_sols - 1] .= padded_shorter_solutions\n            j += num_shorter_sols\n        end\n        return sol_matrix\n    end\nend","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"The polyonmial basis exponents are then given by all possible bardle d:","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"@doc \"\"\"\n    non_negative_solutions_ineq( d :: Int, n :: Int)\n\nReturn a matrix with columns that correspond to solution vectors\n``[x_1, …, x_n]`` to the equation ``x_1 + … + x_n <= d``,\nwhere the variables are non-negative integers.\n\"\"\"\nfunction non_negative_solutions_ineq( d :: Int, n :: Int )\n    return hcat( (non_negative_solutions( d̄, n ) for d̄=0:d )... )\nend","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"note: Note\nI did an unnecessary rewrite of non_negative_solutions to be Zygote-compatible. Therefore the matrices etc. Combinatorics has multiexponents which should do the same...","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"We don't use DynamicPolynomials.jl to generate the Polyomials anymore. Zygote did overflow when there were calculations with those polynomials. Not a problem for calculating the basis (because of we are ignore()ing the basis calculation now, assuming we never want to differentiate with respect to n,d), but when constructing the outputs from them. Instead we directly construct StaticPolynomials and define a PolynomialSystem that evaluates all basis polynomials.","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"@doc \"\"\"\n    canonical_basis( n:: Int, d :: Int ) :: Union{PolynomialSystem, EmptyPolySystem}\n\nReturn the canonical basis of the space of `n`-variate\npolynomials of degree at most `d`.\n\"\"\"\n@memoize ThreadSafeDict function canonical_basis(n :: Int, d::Int, OneType :: Type = Float64)\n    if d < 0\n        return EmptyPolySystem{n}()\n    else\n        exponent_matrix = non_negative_solutions_ineq( d, n )\n        one_float = OneType(1)  # `one_float` is used as coefficient(s) to guarantee floating point output\n        return PolynomialSystem(\n             ( Polynomial( [one_float,], e[:,:] ) for e ∈ eachcol(exponent_matrix) )...\n        )\n    end\nend","category":"page"},{"location":"RadialBasisFunctionModels/#Solving-the-Equation-System","page":"Main Module","title":"Solving the Equation System","text":"","category":"section"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"Now let p_j_1le jle Q be a basis of the polynomial space. Set P =  p_j(x^i)   ℝ^N  Q and Φ = φ( x^i - x^j ). In case of interpolation, the linear equation system for the coefficients of r is","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"S c = beginequation\n    beginbmatrix\n    Φ  P \n    P^T  0_Q  Q\n    endbmatrix\n    beginbmatrix\n        w \n        λ\n    endbmatrix\n    stackrel=\n    beginbmatrix\n    Y\n    \n    0_Q\n    endbmatrix\n    tagI\n    labeleqncoeff\nendequation","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"We can also use differing feature vectors and centers. Φ then becomes Φ = k_j(x^i)_1le i le N_d 1le j le N_c = φ( x^i - ξ^j ), where we denote the number of kernel centers by N_c and the number of feauters (data) by N_d. In the overdetermined least squares case (with pair-wise different centers and pair-wise different features), we do away with the second row of equations in \\eqref{eqn:coeff}. The solution c = w λ^T is then given by the Moore-Penrose Pseudo-Inverse:","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"    c = underbrace ( S^T S )^-1 S^T_=S^dagger beginbmatrix\n    Y\n    \n    0_Q\n    endbmatrix","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"Julia automatically computes the LS solution with S\\RHS.","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"note: Note\nWhen we have vector data Y  ℝ^k, e.g. from modelling MIMO functions, then Julia easily allows for multiple columns in the righthand side of the interpolation equation system and we get weight vectors for multiple models, that can be thought of as one vector model rcolon ℝ^n to ℝ^k.","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"@doc \"\"\"\n    coefficients(sites, values, kernels, rad_funcs, polys )\n\nReturn the coefficient matrices `w` and `λ` for an rbf model\n``r(x) = Σ_{i=1}^N wᵢ φ(\\\\|x - x^i\\\\|) + Σ_{j=1}^M λᵢ pᵢ(x)``,\nwhere ``N`` is the length of `rad_funcs` (and `centers`) and ``M``\nis the length of `polys`.\n\nThe arguments are\n* an array of data sites `sites` with vector entries from ``ℝ^n``.\n* an array of data values `values` with vector entries from ``ℝ^k``.\n* an array of `ShiftedKernel`s.\n* a `PolynomialSystem` or `EmptyPolySystem` (in case of deg = -1).\n\"\"\"\nfunction coefficients(\n        sites, values, kernels, polys; mode :: Symbol = :ls\n    )\n\n    N_c = length(kernels);\n    N_d = length(sites);\n    Q = length(polys)\n\n    if N_d < N_c\n        error(\"Underdetermined models not supported yet.\")\n    end\n    if N_d < Q\n        error(\"Too few data sites for selectod polynomial degree. (Need at least $(Q).)\")\n    end\n\n    Φ = transpose( hcat( map(kernels, sites)... ) )   # N_d × N_c\n    P = transpose( hcat( map(polys, sites)... ) )       # N_d × Q\n    # system matrix S and right hand side\n    S = [Φ P]\n    RHS = transpose( hcat(values... ) );\n\n\n    return _coefficients( Φ, P, S, RHS, Val(:ls) )\nend\n\nfunction _coeff_matrices(coeff :: AbstractMatrix, S, RHS, N_c, Q )\n    return view(coeff, 1 : N_c, :), view(coeff, N_c + 1 : N_c + Q, :), S, RHS\nend\n\nfunction _coeff_matrices(coeff :: StaticMatrix, S, RHS, N_c, Q )\n    return coeff[ SVector{N_c}(1 : N_c), :], coeff[ SVector{Q}( N_c + 1 : N_c + Q ), :], S, RHS\nend\n\nfunction _coefficients( Φ, P, S, RHS, ::Val{:ls} )\n    N_c = size(Φ,2); Q = size(P,2);\n    coeff = S \\ RHS\n    return _coeff_matrices(coeff, S, RHS, N_c, Q )\nend\n\nfunction _coefficients( Φ, P, S, RHS, ::Val{:interpolation} )\n    N_d, N_c = size(Φ); Q = size(P,2);\n    @assert N_d == N_c \"Interpolation requires same number of features and centers.\" # TODO remove assertion\n    S̃ = [ S ;                               # N_d × (N_c + Q)\n          P' zeros(eltype(S), Q, Q )]       # Q × N_d and Q × Q\n    RHS_padded = [ RHS;\n        zeros( eltype(RHS), Q, size(RHS,2) ) ];\n    coeff = S̃ \\ RHS_padded\n    return _coeff_matrices( coeff, S̃, RHS_padded, N_c, Q )\nend\n\n function _coefficients( Φ, P, S :: StaticMatrix, RHS :: StaticMatrix, ::Val{:interpolation} )\n    N_d, N_c = size(Φ); Q = size(P,2);\n    @assert N_d == N_c \"Interpolation requires same number of features and centers.\" # TODO remove assertion\n\n    S̃ = [S ;\n         P' @SMatrix(zeros(eltype(S),Q,Q)) ];\n    RHS_padded = [ RHS;\n        @SMatrix(zeros(eltype(RHS), Q ,size(RHS,2)))];\n    coeff = S̃ \\ RHS_padded\n    return _coeff_matrices( coeff, S̃, RHS_padded, N_c, Q )\nend","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"We can easily impose linear equality constraints, for example requiring interpolation only on a subset of features. In matrix form, I linear equality constraints (for k outputs) can be written as","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"E c = b quad E  ℝ^I(N_c + Q) b  ℝ^Itimes k Ik  ℕ_0","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"Now, let c be the least squares solution from above. The constrained solution is","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":" c = c - Ψ E^T ( E Ψ E^T)^-1 ( E c - b )  Ψ = (S^T S)^-1\ntagCLS1\nlabeleqncls1","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"This results from forming the Lagrangian of an equivalent minimization problem. Let δ = c - c  ℝ^qtimes k q = N_c + Q and define the constraint residuals as γ = Ec - b  ℝ^Itimes k. The Lagrangian for minimizing δ^TS^TSδ under Eδ=γ is","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"beginaligned\n    L = δ^T S^T S δ + 2 λ^T( E δ - γ )\n    D_δL = 2 δ^T S^T S + 2λ^T E \n    D_λL = 2 δ^T E^T - 2 γ^T\nendaligned","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"Setting the derivatives to zero leads to \\eqref{eqn:cls1} via","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"    beginbmatrix\n        S^T S  E^T \n        E  0_Itimes I\n    endbmatrix\n    beginbmatrix\n    δ  λ\n    endbmatrix\n    = beginbmatrix\n    0_qtimes k  γ\n    endbmatrix\ntagL\nlabeleqncls2","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"See [adv_eco] for details.","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"function constrained_coefficients(\n        w :: AbstractMatrix{<:Real},\n        λ :: AbstractMatrix{<:Real},\n        S :: AbstractMatrix{<:Real},\n        E :: AbstractMatrix{<:Real},\n        b :: AbstractMatrix{<:Real}\n    )\n    # Using Lagrangian approach:\n\n    ĉ = [w; λ]  # least squares solution\n    γ = E*ĉ - b # constraint residuals\n\n    I, q = size(E)\n    k = size(w,2)\n\n    A = vcat(\n        [S'S E'],\n        [E zeros(Int,I,I)]\n    )\n\n    RHS = [\n        zeros(Int, q, k);\n        γ\n    ]\n\n    δλ = A \\ RHS\n    δ = δλ[1 : q, :]\n\n    c = ĉ - δ  # coefficients for constrained problem\n\n    N_c = size(w,1)\n\n    return c[1 : N_c, :], c[N_c+1:end, :]\nend","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"For the case that mentioned above, that is, interpolation at a subset of sites, we can easily build the E matrix from the S matrix by taking the corresponding rows.","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"function constrained_coefficients(\n        w :: AbstractMatrix{<:Real},\n        λ :: AbstractMatrix{<:Real},\n        S :: AbstractMatrix{<:Real},\n        RHS_ls :: AbstractMatrix{<:Real},\n        interpolation_indices :: AbstractVector{Int}\n    )\n\n    E = S[interpolation_indices, :]\n    b = RHS_ls[interpolation_indices, :]\n    return constrained_coefficients( w, λ, S, E, b )\nend","category":"page"},{"location":"RadialBasisFunctionModels/#The-Actual,-Usable-Constructor","page":"Main Module","title":"The Actual, Usable Constructor","text":"","category":"section"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"We want the user to be able to pass 1D data as scalars and use the following helpers:","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"ensure_vec_of_vecs( before :: AbstractVector{<:AbstractVector{<:Real}} ) = before\nensure_vec_of_vecs( before :: AbstractVector{ <:Real }) = [[x,] for x in before ]\n\nfunction inner_type( vec_of_vecs :: AbstractVector{<:AbstractVector{T}}) where T\n    if Base.isabstracttype(T)   # like Any if data is of mixed precision\n        return Float64\n    else\n        return T\n    end\nend","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"Helpers to create kernel functions.","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"\"Return array of `ShiftedKernel`s based functions in `φ_arr` with centers from `centers`.\"\nfunction make_kernels( φ_arr :: AbstractVector{<:RadialFunction}, centers :: VecOfVecs )\n    @assert length(φ_arr) == length(centers)\n    [ ShiftedKernel(φ, c) for (φ,c) ∈ zip( φ_arr, centers) ]\nend\n\"Return array of `ShiftedKernel`s based function `φ` with centers from `centers`.\"\nfunction make_kernels( φ :: RadialFunction, centers :: VecOfVecs )\n    [ ShiftedKernel(φ, c) for c ∈ centers ]\nend","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"We now have all ingredients for the basic outer constructor:","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"@doc \"\"\"\n    RBFModel( features, labels, φ = Multiquadric(), poly_deg = 1; kwargs ... )\n\nConstruct a `RBFModel` from the feature vectors in `features` and\nthe corresponding labels in `lables`, where `φ` is a `RadialFunction` or a vector of\n`RadialFunction`s.\\n\nScalar data can be used, it is transformed internally. \\n\nStaticArrays can be used, e.g., `features :: Vector{<:SVector}`.\nProviding `SVector`s only might speed up the construction.\\n\nIf the degree of the polynomial tail, `poly_deg`, is too small it will be set to `cpd_order(φ)-1`.\n\nIf the RBF centers do not equal the the `features`, you can use the keyword argument `centers` to\npass a list of centers. If `φ` is a vector, then the length of `centers` and `φ` must be equal and\n`centers[i]` will be used in conjunction with `φ[i]` to build a `ShiftedKernel`. \\n\nIf `features` has 1D data, the output of the model will be a 1D-vector.\nIf it should be a scalar instead, set the keyword argument `vector_output` to `false`.\n\"\"\"\nfunction RBFModel(\n        features :: AbstractVector{ <:NumberOrVector },\n        labels :: AbstractVector{ <:NumberOrVector },\n        φ :: Union{RadialFunction,AbstractVector{<:RadialFunction}} = Multiquadric(),\n        poly_deg :: Int = 1;\n        centers :: AbstractVector{ <:NumberOrVector } = Vector{Float16}[],\n        interpolation_indices :: AbstractVector{ <: Int } = Int[],\n        vector_output :: Bool = true,\n        coeff_mode :: Symbol = :auto\n    )\n\n    # Basic Data integrity checks\n    @assert !isempty(features) \"Provide at least 1 feature vector.\"\n    @assert !isempty(labels) \"Provide at least 1 label vector.\"\n    num_vars = length(features[1])\n    num_outputs = length(labels[1])\n    @assert all( length(s) == num_vars for s ∈ features ) \"All features must have same dimension.\"\n    @assert all( length(v) == num_outputs for v ∈ labels ) \"All labels must have same dimension.\"\n\n    num_sites = length(features)\n    num_vals = length(labels)\n    @assert num_sites == num_vals \"Provide as many features as labels.\"\n\n    sites = ensure_vec_of_vecs(features)\n    values = ensure_vec_of_vecs(labels)\n    if !isempty(centers)\n        @assert all( length(c) == num_vars for c ∈ centers ) \"All centers must have dimension $(num_vars).\"\n        C = ensure_vec_of_vecs(centers)\n    else\n        C = copy(sites)\n    end\n    num_centers = length(C)\n\n    kernels = make_kernels(φ, C)\n\n    poly_precision = promote_type(Float16, inner_type(sites))\n    poly_basis_sys = Zyg.ignore() do\n        canonical_basis( num_vars, poly_deg, poly_precision )\n    end\n\n    if coeff_mode == :auto\n        can_interpolate_uniquely = φ isa RadialFunction ? poly_deg >= cpd_order(φ) - 1 : all( poly_deg >= cpd_order(phi) - 1 for phi in φ )\n        coeff_mode = num_sites == num_centers && can_interpolate_uniquely ? :interpolation : :ls\n    end\n\n    w, λ, S, RHS = coefficients( sites, values, kernels, poly_basis_sys; mode = coeff_mode )\n\n    if !isempty(interpolation_indices)\n        w, λ = constrained_coefficients( w, λ, S, RHS, interpolation_indices)\n    end\n\n    # build output polynomials\n    poly_sum = PolySum( poly_basis_sys, transpose(λ) )\n\n    # build RBF system\n    rbf_sys = RBFSum(kernels, transpose(w), num_outputs)\n\n    # vector output? (dismiss user choice if labels are vectors)\n    vec_output = num_outputs == 1 ? vector_output : true\n\n    return RBFModel{vec_output, typeof(rbf_sys), typeof(poly_sum)}(\n         rbf_sys, poly_sum, num_vars, num_outputs, num_centers\n    )\nend","category":"page"},{"location":"RadialBasisFunctionModels/#Special-Constructors","page":"Main Module","title":"Special Constructors","text":"","category":"section"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"We offer some specialized models (that simply wrap the main type).","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"struct RBFInterpolationModel\n    model :: RBFModel\nend\n(mod :: RBFInterpolationModel)(args...) = mod.model(args...)\n@forward RBFInterpolationModel.model grad, jac, jacT, auto_grad, auto_jac","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"The constructor is a tiny bit simpler and additional checks take place:","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"\"\"\"\n    RBFInterpolationModel(features, labels, φ, poly_deg; kwargs… )\n\nBuild a model interpolating the feature-label pairs.\nDoes not accept `center` keyword argument.\n\"\"\"\nfunction RBFInterpolationModel(\n        features :: AbstractVector{ <:NumberOrVector },\n        labels :: AbstractVector{ <:NumberOrVector },\n        φ :: Union{RadialFunction,AbstractVector{<:RadialFunction}} = Multiquadric(),\n        poly_deg :: Int = 1;\n        vector_output :: Bool = true,\n    )\n    @assert length(features) == length(labels) \"Provide as many features as labels!\"\n\n    if poly_deg < cpd_order(φ) - 1\n        @warn \"Polyonmial degree too small for interpolation. Using $(cpd_order(φ)-1).\"\n        poly_deg = max( poly_deg,  cpd_order(φ) - 1 )\n    end\n\n    mod = RBFModel(features, labels, φ, poly_deg; vector_output, coeff_mode = :interpolation)\n    return RBFInterpolationModel( mod )\nend","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"We want to provide a convenient alternative constructor for interpolation models so that the radial function can be defined by passing a Symbol or String.","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"const SymbolToRadialConstructor = NamedTuple((\n    :gaussian => Gaussian,\n    :multiquadric => Multiquadric,\n    :inv_multiquadric => InverseMultiquadric,\n    :cubic => Cubic,\n    :thin_plate_spline => ThinPlateSpline\n))\n\n\"Obtain a `RadialFunction` from its name and constructor arguments.\"\nfunction _get_rad_func( φ_symb :: Union{Symbol, String}, φ_args )\n\n    # which radial function to use?\n    radial_symb = Symbol( lowercase( string( φ_symb ) ) )\n    if !(radial_symb ∈ keys(SymbolToRadialConstructor))\n        @warn \"Radial Funtion $(radial_symb) not known, using Gaussian.\"\n        radial_symb = :gaussian\n    end\n\n    constructor = SymbolToRadialConstructor[radial_symb]\n    if isnothing(φ_args)\n        φ = constructor()\n    else\n        φ = constructor( φ_args... )\n    end\n\n    return φ\nend","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"The alternative constructors are build programmatically:","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"for op ∈ [ :RBFInterpolationModel, :RBFModel ]\n    @eval begin\n        function $op(\n                features :: AbstractVector{ <:NumberOrVector },\n                labels :: AbstractVector{ <:NumberOrVector },\n                φ_symb :: Union{Symbol, String},\n                φ_args = nothing,\n                poly_deg :: Int = 1; kwargs...\n            )\n\n            φ = _get_rad_func( φ_symb, φ_args )\n            return $op(features, labels, φ, poly_deg; kwargs... )\n        end\n    end\nend","category":"page"},{"location":"RadialBasisFunctionModels/#Container-with-Training-Data","page":"Main Module","title":"Container with Training Data","text":"","category":"section"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"The RBF Machine is similar in design to what an MLJ machine does: Training data (feature and label vectors) are stored and can be added. The inner model is trained with fit!.","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"TODO In the future, we can customize the fit! method when updating a model to only consider new training data. This also makes type conversion of the whole data arrays unnecessary.","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"\"\"\"\n    RBFMachine(; features = Vector{Float64}[], labels = Vector{Float64}[],\n    kernel_name = :gaussian, kernel_args = nothing, poly_deg = 1)\n\nA container holding an inner `model :: RBFModel` (or `model == nothing`).\nAn array of arrays of features is stored in the `features` field.\nLikewise for `labels`.\nThe model is trained with `fit!` and can then be evaluated.\n\"\"\"\n@with_kw mutable struct RBFMachine{\n        FT <: AbstractVector{<:AbstractVector{<:AbstractFloat}},\n        LT <: AbstractVector{<:AbstractVector{<:AbstractFloat}},\n    }\n    features :: FT = Vector{Float64}[]\n    labels :: LT = Vector{Float64}[]\n    kernel_name :: Symbol = :gaussian\n    kernel_args :: Union{Nothing, Vector{Float64}} = nothing\n    poly_deg :: Int = 1\n\n    model :: Union{Nothing,RBFModel} = nothing\n    valid :: Bool = false   # is model trained on all data sites?\n\n    @assert let T = eltype( Base.promote_eltype(FT, LT) ),\n        K = isnothing(kernel_args) ? nothing : T.(kernel_args),\n        φ = _get_rad_func( kernel_name, K );\n        poly_deg >= cpd_order(φ) - 1\n    end \"Polynomial degree too low for interpolation.\"\nend\n\n\"Return floating point type of training data elements.\"\n_precision( :: RBFMachine{FT,LT} ) where {FT,LT} = eltype( Base.promote_eltype(FT, LT) )\n\n\"Return kernel arguments converted to minimum required precision.\"\nfunction _kernel_args( mach :: RBFMachine )\n    if isnothing( mach.kernel_args )\n        return mach.kernel_args\n    else\n        T = promote_type( Float16, _precision(mach) )\n        return T.(mach.kernel_args)\n    end\nend\n\n\"Fit `mach :: RBFMachine` to the training data.\"\nfunction fit!( mach :: RBFMachine )::Nothing\n    @assert length(mach.features) > 0 \"Provide at least one data sample.\"\n    num_needed =  binomial( mach.poly_deg + length(mach.features[1]), mach.poly_deg)\n    @assert length(mach.features) >= num_needed \"Too few data sites for selected polynomial degree (need $(num_needed)).\"\n\n    inner_model = RBFModel(\n        mach.features,\n        mach.labels,\n        mach.kernel_name,\n        _kernel_args(mach),\n        mach.poly_deg\n    )\n    mach.model = inner_model\n    mach.valid = true\n    return nothing\nend","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"Forward evaluation methods of inner model:","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"( mach :: RBFMachine )(args...) = mach.model(args...)\n@forward RBFMachine.model grad, jac, jacT, auto_grad, auto_jac","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"Methods to add features and labels:","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"\"Add a feature vector(s) and a label(s) to the `machine` container.\"\nfunction add_data!(\n        m :: RBFMachine, features :: AbstractVector{<:AbstractVector}, labels :: AbstractVector{<:AbstractVector}\n    ) :: Nothing\n    @assert length(features) == length(labels) \"Provide same number of features and labels.\"\n    @assert all( length(f) == length(features[1]) for f in features ) \"Features must have same length.\"\n    @assert all( length(l) == length(labels[1]) for l in labels ) \"Labels must have same length\"\n    @assert isempty(m.features) || length(m.features[1]) == length(features[1]) && length(m.labels[1]) == length(labels[1]) \"Length doesnt match previous data.\"\n    append!(m.features, features)\n    append!(m.labels, labels)\n    m.valid = false\n    return nothing\nend\n\nfunction add_data!(\n        m :: RBFMachine, feature :: AbstractVector{<:AbstractFloat}, label:: AbstractVector{<:AbstractFloat}\n    ) :: Nothing\n    return add_data!(m, [ feature, ], [label, ])\nend","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"Convenience methods to \"reset\" a machine:","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"function Base.empty!( m :: RBFMachine ) :: Nothing\n    empty!(m.features)\n    empty!(m.labels)\n    m.model = nothing\n    m.valid = false\n    return nothing\nend\n\nfunction Base.isempty(m :: RBFMachine ) :: Bool\n    isempty( m.features ) && isempty( m.labels ) && isnothing(m.model)\nend","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"include(\"mlj_interface.jl\")","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"[wild_diss]: “Derivative-Free Optimization Algorithms For Computationally Expensive Functions”, Wild, 2009.","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"[wendland]: “Scattered Data Approximation”, Wendland","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"[adv_eco]: “Advanced Econometrics“, Takeshi Amemiya","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"","category":"page"},{"location":"RadialBasisFunctionModels/","page":"Main Module","title":"Main Module","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = RadialBasisFunctionModels","category":"page"},{"location":"#RadialBasisFunctionModels","page":"Home","title":"RadialBasisFunctionModels","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
