var documenterSearchIndex = {"docs":
[{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"EditURL = \"https://github.com/manuelbb-upb/RBFModels.jl/blob/master/src/RBFModels.jl\"","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"export auto_grad, auto_jac, grad, jac","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"Dependencies of this module:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"import DynamicPolynomials as DP\nusing StaticPolynomials\nusing ThreadSafeDicts\nusing Memoize: @memoize\nusing StaticArrays\nusing LinearAlgebra: norm\nusing Lazy: @forward\n\nimport Flux.Zygote as Zyg\n#using Flux.Zygote: Buffer, @adjoint","category":"page"},{"location":"RBFModels/#Radial-Basis-Function-Models","page":"Main Module","title":"Radial Basis Function Models","text":"","category":"section"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"The sub-module RBFModels provides utilities to work with radial basis function [RBF] models. Given N data sites X =  x^1  x^N   ℝ^n and values Y =  y^1  y^N   ℝ, an interpolating RBF model rcolon ℝ^n  ℝ has the form","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"r(x) = sum_i=1^N w_i φ(  x - x^i _2 ) + p(x)","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"where p is a multivariate polynomial. The radial function φcolon 0 ) to ℝ defines the RBF and we can solve for the coefficients w by solving the interpolation system","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"r( x^i ) stackrel= y^i quad textfor all i=1N","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"For the interpolation system to be solvable we have to choose the right polynomial space for p. Basically, if the RBF Kernel (or the radial function) is conditionally positive definite of order D we have to find a polynomial p with deg p ge D-1.[wendland] If the kernel is CPD of order D=0 we do not have to add an polynomial and can interpolate arbitrary (distinct) data points. \nNow let p_j_1le jle Q be a basis of the polynomial space. Set P =  p_j(x^i)   ℝ^N  Q and Φ = φ( x^i - x^j ). In case of interpolation, the linear equation system for the coefficients of r is","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"    beginbmatrix\n    Φ  P \n    P^T  0_Q  Q\n    endbmatrix\n    beginbmatrix\n        w \n        λ\n    endbmatrix\n    =\n    beginbmatrix\n    Y\n    \n    0_Q\n    endbmatrix","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"We can also use differing feature vectors and centers. It is also possible to determine a least squarse solution to a overdetermined system. Hence, we will denote the number of kernel centers by N_c from now on.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"note: Note\nWhen we have vector data Y  ℝ^k, e.g. from modelling MIMO functions, then Julia easily allows for multiple columns in the righthand side of the interpolation equation system and we get weight vectors for multiple models, that can be thought of as one vector models rcolon ℝ^n to ℝ.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"note: Note\nSee the section about Constructors for how we actually solve the equation system.","category":"page"},{"location":"RBFModels/#Radial-Basis-Function-Sum.","page":"Main Module","title":"Radial Basis Function Sum.","text":"","category":"section"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"The function k() = φ(_2) is radially symmetric around the origin. k is called the kernel of an RBF.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"We define an abstract super type for radial functions:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"abstract type RadialFunction <: Function end","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"Each Type that inherits from RadialFunction should implement an evaluation method. It takes the radius/distance ρ = ρ(x) =  x - x^i  from x to a specific center x^i.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"(φ :: RadialFunction )( ρ :: Real ) :: Real = Nothing;\nnothing #hide","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"We also need the so called order of conditional positive definiteness:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"cpd_order( φ :: RadialFunction) :: Int = nothing;\nnothing #hide","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"The derivative can also be specified. It defaults to","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"df( φ :: RadialFunction, ρ ) = Zyg.gradient( φ, ρ )[1]","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"The file radial_funcs.jl contains various radial function implementations.","category":"page"},{"location":"RBFModels/#Some-Radial-Functions","page":"Main Module","title":"Some Radial Functions","text":"","category":"section"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"The Gaussian is defined by φ(ρ) = exp left( - (αρ)^2 right), where α is a shape parameter to fine-tune the function.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"\"\"\"\n    Gaussian( α = 1 ) <: RadialFunction\n\nA `RadialFunction` with\n```math\n    φ(ρ) = \\\\exp( - (α ρ)^2 ).\n```\n\"\"\"\nstruct Gaussian <: RadialFunction\n    α :: Real\n\n    Gaussian( α :: Real = 1 ) = begin\n        @assert α > 0 \"The shape parameter `α` must be positive.\"\n        return new(α)\n    end\nend\n\nfunction ( φ :: Gaussian )( ρ :: Real )\n    exp( - (φ.α * ρ)^2 )\nend\n\ncpd_order( :: Gaussian ) = 0\ndf(φ :: Gaussian, ρ :: Real) = - 2 * φ.α * φ( ρ )","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"The Multiquadric is φ(ρ) = - sqrt 1 + (αρ)^2  and also has a positive shape parameter. We can actually generalize it to the following form:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"\"\"\"\n    Multiquadric( α = 1, β = 1//2 ) <: RadialFunction\n\nA `RadialFunction` with\n```math\n    φ(ρ) = (-1)^{ \\\\lceil β \\\\rceil } ( 1 + (αρ)^2 )^β\n```\n\"\"\"\nstruct Multiquadric <: RadialFunction\n    α :: Real   # shape parameter\n    β :: Real   # exponent\n\n    Multiquadric(α = 1, β = 1//2 ) = begin\n        @assert α > 0 \"The shape parameter `α` must be positive.\"\n        @assert β % 1 != 0 \"The exponent must not be an integer.\"\n        @assert β > 0 \"The exponent must be positive.\"\n        new(α,β)\n    end\nend\n\nfunction ( φ :: Multiquadric )( ρ :: Real )\n    (-1)^(ceil(Int, φ.β)) * ( 1 + (φ.α * ρ)^2 )^φ.β\nend\n\ncpd_order( φ :: Multiquadric ) = ceil( Int, φ.β )\ndf(φ :: Multiquadric, ρ :: Real ) = (-1)^(ceil(Int, φ.β)) * 2 * φ.α * φ.β * ρ * ( 1 + (φ.α * ρ)^2 )^(φ.β - 1)","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"Related is the Inverse Multiquadric φ(ρ) = (1+(αρ)^2)^-β is related:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"\"\"\"\n    InverseMultiquadric( α = 1, β = 1//2 ) <: RadialFunction\n\nA `RadialFunction` with\n```math\n    φ(ρ) = ( 1 + (αρ)^2 )^{-β}\n```\n\"\"\"\nstruct InverseMultiquadric <: RadialFunction\n    α :: Real\n    β :: Real\n\n    InverseMultiquadric( α = 1, β = 1//2 ) = begin\n        @assert α > 0 \"The shape parameter `α` must be positive.\"\n        @assert β > 0 \"The exponent must be positive.\"\n        new(α, β)\n    end\nend\n\nfunction ( φ :: InverseMultiquadric )( ρ :: Real )\n   ( 1 + (φ.α * ρ)^2 )^(-φ.β)\nend\n\ncpd_order( :: InverseMultiquadric ) = 0\ndf(φ :: InverseMultiquadric, ρ :: Real ) = - 2 * φ.α^2 * φ.β * ρ * ( 1 + (φ.α * ρ)^2 )^(-φ.β - 1)","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"The Cubic is φ(ρ) = ρ^3. It can also be generalized:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"\"\"\"\n    Cubic( β = 3 ) <: RadialFunction\n\nA `RadialFunction` with\n```math\n    φ(ρ) = (-1)^{ \\\\lceil β \\\\rceil /2 } ρ^β\n```\n\"\"\"\nstruct Cubic <: RadialFunction\n    β :: Real\n\n    Cubic( β :: Real = 3 ) = begin\n        @assert β > 0 \"The exponent `β` must be positive.\"\n        @assert β % 2 != 0 \"The exponent `β` must not be an even number.\"\n        new(β)\n    end\nend\n\nfunction ( φ :: Cubic )( ρ :: Real )\n    (-1)^ceil(Int, φ.β/2 ) * ρ^φ.β\nend\n\ncpd_order( φ :: Cubic ) = ceil( Int, φ.β/2 )\ndf(φ :: Cubic, ρ :: Real ) = (-1)^(ceil(Int, φ.β/2)) * φ.β * ρ^(φ.β - 1)","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"The thin plate spline is usually defined via φ(ρ) = ρ^2 log( ρ ). We provide a generalized version, which defaults to φ(ρ) = - ρ^4 log( ρ ).","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"\"\"\"\n    ThinPlateSpline( k = 2 ) <: RadialFunction\n\nA `RadialFunction` with\n```math\n    φ(ρ) = (-1)^{k+1} ρ^{2k} \\\\log(ρ)\n```\n\"\"\"\nstruct ThinPlateSpline <: RadialFunction\n    k :: Int\n\n    ThinPlateSpline( k :: Real = 2 ) = begin\n        @assert k > 0 && k % 1 == 0 \"The parameter `k` must be a positive integer.\"\n        new( Int(k) )\n    end\nend\n\nfunction (φ :: ThinPlateSpline )( ρ :: Real )\n    (-1)^(k+1) * ρ^(2*k) * log( ρ )\nend\n\ncpd_order( φ :: ThinPlateSpline ) = φ.k + 1\ndf(φ :: ThinPlateSpline, ρ :: Real ) = ρ == 0 ? 0 : (-1)^(φ.k+1) * ρ^(2*φ.k - 1) * ( 2 * φ.k * log(ρ) + 1)","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"From an RadialFunction and a vector we can define a shifted kernel function. We allow evaluation for statically sized vectors, too:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"const StatVec{T} = Union{SVector{I,T}, SizedVector{I,T,V}} where {I,V}\nconst AnyVec{T} = Union{Vector{T}, StatVec{T}}\nconst AnyMat = Union{Matrix, SMatrix, SizedMatrix}\n\nstruct ShiftedKernel <: Function\n    φ :: RadialFunction\n    c :: AnyVec\nend\n\nnorm2( vec ) = norm(vec, 2)\n\n\"Evaluate kernel `k` at `x - k.c`.\"\nfunction (k::ShiftedKernel)( x :: AnyVec{<:Real} )\n    return k.φ( norm2( x - k.c ) )\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"A vector of N kernels is a mapping ℝ^n  ℝ^N  x   k₁(x)  k_N(x).","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"\"Evaluate ``x ↦ [ k₁(x), …, k_{N_c}(x)]`` at `x`.\"\nfunction ( K::AnyVec{ShiftedKernel})( x :: AnyVec{<:Real} )\n    [ k(x) for k ∈ K ]\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"Suppose, we have calculated the distances x - x^i beforehand. We can save redundant effort by passing them to the radial fucntions of the kernels.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"\"Evaluate `k.φ` for distance `ρ` where `ρ` should equal `x - k.c` for the argument `x`.\"\neval_at_dist( k :: ShiftedKernel , ρ :: Real ) = k.φ(ρ)\n\n\"Evaluate ``x ↦ [ k₁(x), …, k_{N_c}(x)]``, provided the distances ``[ ρ_1(x), …, ρ_{N_c}(x) ]``.\"\nfunction eval_at_dist( K::AnyVec{ShiftedKernel}, dists :: Vector{<:Real})\n    [ eval_at_dist(k,ρ) for (k,ρ) ∈ zip(K,dists) ]\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"Provided we have solved the interpolation system, the weights for the radial basis function part of r are w, where w is a vector of length N_c or a matrix in ℝ^N_c times k where k is the number of outputs. We treat the general case kge 1 and always assume w to be a matrix.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"struct RBFSum\n    kernels :: AnyVec{ShiftedKernel}\n    weights :: AnyMat # weigth vectors, one for each output\n\n    # information fields\n    num_vars :: Int\n    num_centers :: Int\n    num_outputs :: Int\n\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"We can easily evaluate the ℓ-th output of the RBFPart.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"\"Evaluate output `ℓ` of RBF sum `rbf::RBFSum`\"\nfunction (rbf :: RBFSum)(x :: AnyVec{<:Real}, ℓ :: Int)\n    (rbf.kernels(x)'rbf.weights[:,ℓ])[1]\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"Use the above method for vector-valued evaluation of the whole sum:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"\"Evaluate `rbf::RBFSum` at `x`.\"\n(rbf::RBFSum)( x :: AnyVec{<:Real} ) = vec(rbf.kernels(x)'rbf.weights)","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"As before, we allow to pass precalculated distance vectors:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"function eval_at_dist( rbf::RBFSum, dists :: AnyVec{<:Real}, ℓ :: Int )\n   eval_at_dist( rbf.kernels, dists )'rbf.weights\nend\n\nfunction eval_at_dist( rbf :: RBFSum, dists :: AnyVec{<:Real})\n   vec(eval_at_dist(rbf.kernels, dists )'rbf.weights)\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"For the PolynomialTail we use a StaticPolynomials.PolynomialSystem. \nWe now have all ingredients to define the model type.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"\"\"\"\n    RBFModel{V}\n\n* `V` is `true` by default. It can be set to `false` only if the number\n  of outputs is 1. Then scalars are returned.\n\n\"\"\"\nstruct RBFModel{V}\n    rbf :: RBFSum\n    polys :: PolynomialSystem\n\n    # Information fields\n    num_vars :: Int\n    num_outputs :: Int\n    num_centers :: Int\n    #=\n    function RBFModel( rbf :: RBFSum, polys :: PolynomialSystem, V :: Bool )\n        num_centers = rbf.num_centers\n        num_vars = num_centers > 0 ? length(rbf.kernels[1].c) : nvariables(polys)\n        num_outputs = rbf.num_outputs > 0 ? rbf.num_outputs : npolynomials(polys)\n\n        vec_out = num_outputs == 1 ? V : true\n        return new{vec_out}(\n            num_vars,\n            num_outputs,\n            num_centers\n        )\n    end\n    =#\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"We want a model to be displayed in a sensible way:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"function Base.show( io :: IO, mod :: RBFModel{V} ) where V\n    compact = get(io, :compact, false)\n    if compact\n        print(io, \"$(mod.num_vars)D$(mod.num_outputs)D-RBFModel{$(V)}\")\n    else\n        print(io, \"RBFModel\\n\")\n        if !V print(io, \"* with scalar output\\n\") end\n        print(io, \"* with $(mod.num_centers) centers\\n\")\n        print(io, \"* mapping from ℝ^$(mod.num_vars) to ℝ^$(mod.num_outputs).\")\n    end\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"Evaluation is easy. We accept an additional ::Nothing argument that does nothing for now, but saves some typing later.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"function vec_eval(mod :: RBFModel, x :: AnyVec{<:Real}, :: Nothing)\n    return mod.rbf(x) .+ mod.polys( x )\nend\n\nfunction scalar_eval(mod :: RBFModel, x :: AnyVec{<:Real}, :: Nothing )\n    return (mod.rbf(x) .+ mod.polys( x ))[1]\nend\n\n\"Evaluate model `mod :: RBFModel` at vector `x`.\"\n( mod :: RBFModel{true} )(x :: AnyVec{<:Real}, ℓ :: Nothing = nothing ) = vec_eval(mod,x,ℓ)\n( mod :: RBFModel{false} )(x :: AnyVec{<:Real}, ℓ :: Nothing = nothing ) = scalar_eval(mod,x,ℓ)\n\n\"Evaluate scalar output `ℓ` of model `mod` at vector `x`.\"\nfunction (mod :: RBFModel)( x :: AnyVec{<:Real}, ℓ :: Int)\n    return mod.rbf(x, ℓ) .+ mod.polys.polys[ℓ]( x )\nend\n\n# scalar input\nconst NothInt = Union{Nothing,Int}\n\nfunction (mod :: RBFModel)(x :: Real, ℓ :: NothInt = nothing )\n    @assert mod.num_vars == 1 \"The model has more than 1 inputs. Provide a vector `x`, not a number.\"\n    mod( [x,], ℓ)\nend","category":"page"},{"location":"RBFModels/#Derivatives","page":"Main Module","title":"Derivatives","text":"","category":"section"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"The easiest way to provide derivatives is via Automatic Differentiation. We have imported Flux.Zygote as Zyg. For automatic differentiation we need custom adjoints for some StaticArrays:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"Zyg.@adjoint (T::Type{<:SizedMatrix})(x::AbstractMatrix) = T(x), dv -> (nothing, dv)\nZyg.@adjoint (T::Type{<:SizedVector})(x::AbstractVector) = T(x), dv -> (nothing, dv)\nZyg.@adjoint (T::Type{<:SArray})(x::AbstractArray) = T(x), dv -> (nothing, dv)","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"This allows us to define the following methods:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"\"Return the jacobian of `rbf` at `x` (using Zygote).\"\nfunction auto_jac( rbf :: RBFModel, x :: AnyVec{<:Real} )\n    Zyg.jacobian( rbf, x )[1]\nend\n\n\"Evaluate the model and return the jacobian at the same time.\"\nfunction eval_and_auto_jac( rbf :: RBFModel, x :: AnyVec{<:Real} )\n    y, back = Zyg._pullback( rbf, x )\n\n    T = eltype(y)   # TODO does this make sense?\n    n = length(y)\n    jac = zeros(T, n, length(x) )\n    for i = 1 : length(x)\n        e = [ zeros(T, i -1 ); T(1); zeros(T, n - i )  ]\n        jac[i, :] .= back(e)[2]\n    end\n\n    return y, jac\nend\n\n\"Return gradient of output `ℓ` of model `rbf` at point `x` (using Zygote).\"\nfunction auto_grad( rbf :: RBFModel, x :: AnyVec{<:Real}, ℓ :: Int = 1)\n    Zyg.gradient( χ -> rbf(χ, ℓ), x )[1]\nend\n\n\"Evaluate output `ℓ` of the model and return the gradient.\"\nfunction eval_and_auto_grad( rbf :: RBFModel, x :: AnyVec{<:Real}, ℓ :: Int = 1 )\n    y, back = Zyg._pullback( χ -> rbf(χ, ℓ)[end], x)\n\n    grad = back( one(y) )[2]\n    return y, grad\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"note: Note\nWe need at least ChainRules@v.0.7.64 to have auto_grad etc. work for StaticArrays, see this issue.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"note: Note\nThe above methods do not work if x is a StaticArray due to StaticPolynomials not knowing the custom adjoints. Maybe extendings ChainRulesCore helps?","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"But we don't need Zygote, because we can derive the gradients ourselves. Assume that φ is two times continuously differentiable. \nWhat is the gradient of a scalar RBF model? Using the chain rule and ξ = x - x^j we get","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"dfracξ_i left( φ( ξ ) right)\n=\nφprime (  ξ  ) cdot\ndfracξ_i (  ξ  )\n=\nφprime (  ξ  ) cdot\ndfracξ_iξ","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"The right term is always bounded, but not well defined for ξ = 0 (see [wild_diss] for details). \nThat is why we require φ(0) stackrel= 0. \nWe have dfracx_i ξ(x) = 1 and thus","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"r(x) = sum_i=1^N fracw_i φprime(  x - x^i  ) x - x^i  (x - x^i) + p(x)","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"We can then implement the formula from above. For a fixed center x^i let o be the distance vector x - x^i and let ρ be the norm ρ = o =  x- x^i . Then, the gradient of a single kernel is:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"function grad( k :: ShiftedKernel, o :: AnyVec{<:Real}, ρ :: Real )\n    ρ == 0 ? zero(k.c) : (df( k.φ, ρ )/ρ) .* o\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"In terms of x:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"function grad( k :: ShiftedKernel, x :: AnyVec{<:Real} )\n    o = x - k.c     # offset vector\n    ρ = norm2( o )  # distance\n    return grad( k, o, ρ )\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"The jacobion of a vector of kernels follows suit:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"function jacT( K :: AnyVec{ShiftedKernel}, x :: AnyVec{<:Real})\n    hcat( ( grad(k,x) for k ∈ K )... )\nend\n# precalculated offsets and distances, 1 per kernel\nfunction jacT( K :: AnyVec{ShiftedKernel}, offsets :: AnyVec{<:AnyVec}, dists :: AnyVec{<:Real} )\n    hcat( ( grad(k,o,ρ) for (k,o,ρ) ∈ zip(K,offsets,dists) )... )\nend\njac( K :: AnyVec{ShiftedKernel}, args... ) = transpose( jacT(K, args...) )","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"Hence, the gradients of an RBFSum are easy:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"function grad( rbf :: RBFSum, x :: AnyVec{<:Real}, ℓ :: Int = 1 )\n    vec( jacT( rbf.kernels, x) * rbf.weights[:,ℓ] )\nend\n\nfunction grad( rbf :: RBFSum, offsets :: AnyVec{<:AnyVec}, dists :: AnyVec{<:Real}, ℓ :: Int)\n    return vec( jacT( rbf.kernels, offsets, dists ) * rbf.weights[:,ℓ] )\nend\n\nfunction grad( mod :: RBFModel, x :: AnyVec{<:Real}, ℓ :: Int = 1 )\n    grad(mod.rbf, x, ℓ) + gradient( mod.polys.polys[ℓ], x )\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"We can exploit our custom evaluation methods for \"distances\":","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"function eval_and_grad( rbf :: RBFSum, offsets :: AnyVec{<:AnyVec}, dists :: AnyVec{<:Real}, ℓ :: Int)\n    return eval_at_dist( rbf, dists, ℓ ), grad( rbf, offsets, dists, ℓ)\nend\n\nfunction eval_and_grad( rbf :: RBFSum, x :: AnyVec{<:Real}, ℓ :: Int = 1)\n    offsets = [ x - k.c for k ∈ rbf.kernels ]\n    dists = norm2.(offsets)\n    return eval_and_grad( rbf, offsets, dists, ℓ)\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"For the jacobian, we use this trick to save evaluations, too.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"function jacT( rbf :: RBFSum, x :: AnyVec{<:Real} )\n    offsets = [ x - k.c for k ∈ rbf.kernels ]\n    dists = norm2.(offsets)\n    jacT( rbf.kernels, offsets, dists )*rbf.weights\nend\njac(rbf :: RBFSum, args... ) = transpose( jacT(rbf, args...) )\n\nfunction jac( mod :: RBFModel, x :: AnyVec{<:Real} )\n    jac( mod.rbf, x) + jacobian( mod.polys, x )\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"note: Note\nHessians are not yet implemented.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"For the Hessian Hr colon ℝ^n to ℝ^ntimes n we need the gradients of the component functions","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"    ψ_j(ξ) = frac φ( left ξ right )ξ ξ_j","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"Suppose ξ  0. First, using the product rule, we have","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"   dfracξ_i\n   left(\n   frac φ( left ξ right )ξ ξ_j\n   right) =\n   ξ_j\n   dfracξ_i\n   left(\n   frac φ( left ξ right )ξ\n   right)\n   +\n   frac φ( left ξ right )ξ\n   dfracξ_i\n   ξ_j","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"The last term is easy because of","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"fracξ_i ξ_j\n=\nbegincases\n    1  textif i = j\n    0  textelse\nendcases","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"For the first term we find","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"   dfracξ_i\n   left(\n     frac φ( left ξ right )\n      ξ\n   right)\n   =\n   frac\n       φleft(left ξ rightright) _i ξ\n       - ξ _i φleft( left ξ rightright)\n    \n        ξ^2\n    \n    =\n    frac\n        dfracφ(ξ)ξ ξ_i - ξφ(ξ)dfracξ_iξ\n    ξ^2","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"Hence, the gradient of ψ_j is","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"    ψ_j(ξ)\n    =\n    left( fracφ(ξ)ξ^3\n    -\n    fracφ(ξ)ξ^2 right) cdot ξ\n    -fracφ(ξ)ξ e^j","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"where e^j  ℝ^n is all zeros, except e^j_j = 1. For ξ = 0 the first term vanishes due to L'Hôpital's rule:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"ψ_j(0) = φ(0) e^j","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"This file is included from within RBFModels.jl #src","category":"page"},{"location":"RBFModels/#Constructors","page":"Main Module","title":"Constructors","text":"","category":"section"},{"location":"RBFModels/#Polynomial-Basis","page":"Main Module","title":"Polynomial Basis","text":"","category":"section"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"Any constructor of an RBFModel must solve for the coefficients. To build the equation system, we need a basis p_j_1 le j le Q of Π_d(ℝ^n).","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"The canonical basis is x_1^α_1 x_2^α_2  x_n^α_n with α_i  0 and Σ_i α_i  d. For bard le d we can recursively get the non-negative integer solutions for Σ_i α_i = bard with the following function:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"@doc \"\"\"\n    non_negative_solutions( d :: Int, n :: Int)\n\nReturn array of solution vectors ``[x_1, …, x_n]`` to the equation\n``x_1 + … + x_n = d``\nwhere the variables are non-negative integers.\n\"\"\"\nfunction non_negative_solutions( d :: Int, n :: Int )\n    if n == 1\n        return d\n    else\n        solutions = [];\n        for i = 0 : d\n            # make RHS smaller by and find all solutions of length `n-1`\n            # then concatenate with difference `d-i`\n            for shorter_solution ∈ non_negative_solutions( i, n - 1)\n                push!( solutions, [ d-i ; shorter_solution ] )\n            end\n        end\n        return solutions\n    end\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"We use DynamicPolynomials.jl to generate the Polyomials. Furthermore, we employ Memoization (via Memoize.jl and ThreadSafeDicts) to save the result for successive usage.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"@doc \"\"\"\n    canonical_basis( n:: Int, d :: Int )\n\nReturn the canonical basis of the space of `n`-variate\npolynomials of degree at most `d`.\n\"\"\"\n@memoize ThreadSafeDict function canonical_basis( n :: Int, d :: Int )\n    DP.@polyvar Xvar[1 : n]\n    basis = DP.Polynomial{true,Int}[] # list of basis polynomials\n    for d̄ = 0 : d\n        for multi_exponent ∈ non_negative_solutions( d̄, n )\n            push!( basis, DP.Polynomial(prod( Xvar .^ multi_exponent ) ))\n        end\n    end\n    return basis\nend","category":"page"},{"location":"RBFModels/#Solving-the-Equation-System","page":"Main Module","title":"Solving the Equation System","text":"","category":"section"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"For now, we use the \\ operator to solve A * coeff = RHS. Furthermore, we allow for different interpolation sites and RBF centers by allowing for passing kernels.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"const VecOfVecs{T} = AnyVec{<:AnyVec{<:T}}\n\n@doc \"\"\"\n    coefficients(sites, values, kernels, rad_funcs, polys )\n\nReturn the coefficient matrices `w` and `λ` for an rbf model\n``r(x) = Σ_{i=1}^N wᵢ φ(\\\\|x - x^i\\\\|) + Σ_{j=1}^M λᵢ pᵢ(x)``,\nwhere ``N`` is the length of `rad_funcs` (and `centers`) and ``M``\nis the length of `polys`.\n\nThe arguments are\n* an array of data sites `sites` with vector entries from ``ℝ^n``.\n* an array of data values `values` with vector entries from ``ℝ^k``.\n* an array of `ShiftedKernel`s.\n* an array `polys` of polynomial basis functions.\n\"\"\"\nfunction coefficients(\n        sites :: VecOfVecs,\n        values :: VecOfVecs,\n        kernels :: AnyVec{ShiftedKernel},\n        polys :: Vector{<:DP.Polynomial};\n    )\n\n    n_out = length(values[1])\n\n    # Φ-matrix, N columns =̂ basis funcs, rows =̂ sites\n    N = length(kernels);\n    Φ = hcat( (k.(sites) for k ∈ kernels)... )\n\n    # P-matrix, N × Q\n    Q = length(polys)\n    P = hcat( (p.(sites) for p ∈ polys)... )\n\n    # system matrix A\n    Z = zeros( eltype(Φ), Q, Q )\n    A = [ Φ  P;\n          P' Z ];\n\n    # build rhs\n    RHS = [\n        transpose( hcat( values... ) );\n        zeros( eltype(eltype(values)), Q, n_out )\n    ];\n\n    # solve system\n    coeff = A \\ RHS\n\n    # return w and λ\n    return coeff[1 : N, :], coeff[N+1 : end, :]\nend","category":"page"},{"location":"RBFModels/#The-Actual,-Usable-Constructor","page":"Main Module","title":"The Actual, Usable Constructor","text":"","category":"section"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"We want the user to be able to pass 1D data as scalars and use the following helpers:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"const NumberOrVector = Union{<:Real, AnyVec{<:Real}}\n\nfunction ensure_vec_of_vecs( before :: AnyVec{ <:Real } )\n    [ SVector{1}([vec,]) for vec ∈ before ]\nend\nensure_vec_of_vecs( before :: AnyVec{ <:AnyVec } ) = before","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"Helpers to create kernel functions. Should return SVector when appropriate.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"\"Return array of `ShiftedKernel`s based functions in `φ_arr` with centers from `centers`.\"\nfunction make_kernels( φ_arr :: AnyVec{<:RadialFunction}, centers :: VecOfVecs )\n    @assert length(φ_arr) == length(centers)\n    [ ShiftedKernel(φ_arr[i], centers[i]) for i = eachindex( centers ) ]\nend\n\"Return array of `ShiftedKernel`s based function `φ` with centers from `centers`.\"\nfunction make_kernels( φ :: RadialFunction, centers :: VecOfVecs )\n    [ ShiftedKernel(φ, centers[i]) for i = eachindex( centers ) ]\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"We use these methods to construct the RBFSum of a model","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"function RBFSum( kernels :: AnyVec{<:ShiftedKernel}, weights :: AnyMat,\n        num_vars :: Int = -1, num_centers ::Int = -1, num_outputs :: Int = -1;\n        static_arrays :: Bool = true\n    )\n    if num_vars < 0 num_vars = length(kernels[1].c) end\n    if num_centers < 0 num_centers = length(kernels) end\n    if num_outputs < 0 num_outputs = length(weights) end\n\n    # Sized Matrix?\n    @assert size(weights) == (num_centers, num_outputs) \"Weights must have dimensions $((num_centers, num_outputs)) instead of $(size(weights)).\"\n    if num_centers * num_outputs < 100 && static_arrays\n        if !( weights isa StaticArray)\n            weights = SMatrix{num_centers, num_outputs}(weights)\n        end\n    end\n\n    #w_vecs = copy.(eachcol(weights))\n\n    RBFSum( kernels, weights, num_vars, num_centers, num_outputs)\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"We now have all ingredients for the basic outer constructor:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"@doc \"\"\"\n    RBFModel( features, labels, φ = Multiquadric(), poly_deg = 1; kwargs ... )\n\nConstruct a `RBFModel` from the feature vectors in `features` and\nthe corresponding labels in `lables`, where `φ` is a `RadialFunction` or a vector of\n`RadialFunction`s.\\n\nScalar data can be used, it is transformed internally. \\n\nStaticArrays can be used, e.g., `features :: Vector{<:SVector}`.\nProviding `SVector`s only might speed up the construction.\\n\nIf the degree of the polynomial tail, `poly_deg`, is too small it will be set to `cpd_order(φ)-1`.\n\nIf the RBF centers do not equal the the `features`, you can use the keyword argument `centers` to\npass a list of centers. If `φ` is a vector, then the length of `centers` and `φ` must be equal and\n`centers[i]` will be used in conjunction with `φ[i]` to build a `ShiftedKernel`. \\n\nIf `features` has 1D data, the output of the model will be a 1D-vector.\nIf it should be a scalar instead, set the keyword argument `vector_output` to `false`.\n\"\"\"\nfunction RBFModel(\n        features :: AnyVec{ <:NumberOrVector },\n        labels :: AnyVec{ <:NumberOrVector },\n        φ :: Union{RadialFunction,AnyVec{<:RadialFunction}} = Multiquadric(),\n        poly_deg :: Int = 1;\n        centers :: AnyVec{ <:NumberOrVector } = Vector{Float16}[],\n        interpolation_indices :: AnyVec{ <: Int } = Int[],\n        vector_output :: Bool = true,\n        static_arrays :: Bool = true\n    )\n\n    # Basic Data integrity checks\n    @assert !isempty(features) \"Provide at least 1 feature vector.\"\n    @assert !isempty(labels) \"Provide at least 1 label vector.\"\n    num_vars = length(features[1])\n    num_outputs = length(labels[1])\n    @assert all( length(s) == num_vars for s ∈ features ) \"All features must have same dimension.\"\n    @assert all( length(v) == num_outputs for v ∈ labels ) \"All labels must have same dimension.\"\n\n    if !isempty( centers )\n        @assert all( length(s) == num_vars for s ∈ centers ) \"All centers must have dimension $(num_vars).\"\n    else\n        centers = features\n    end\n\n    sites = ensure_vec_of_vecs(features)\n    values = ensure_vec_of_vecs(labels)\n    centers = ensure_vec_of_vecs(centers)\n\n    # Use static arrays if there are not too many variables\n    if num_vars < 100 && static_arrays\n        if !(centers[1] isa StaticArray)\n            centers = [ SVector{num_vars}(c) for c ∈ centers ]\n        end\n    end\n\n    kernels = make_kernels( φ, centers )\n    poly_deg = max( poly_deg, cpd_order(φ) - 1 , -1 )\n    poly_basis = canonical_basis( num_vars, poly_deg )\n\n    w, λ = coefficients( sites, values, kernels, poly_basis )\n\n    # build output polynomials\n    poly_vec = StaticPolynomials.Polynomial[]\n    for coeff_ℓ ∈ eachcol( λ )\n        push!( poly_vec, StaticPolynomials.Polynomial( poly_basis'coeff_ℓ ) )\n    end\n    poly_sys = PolynomialSystem( poly_vec... )\n\n    # build RBF system\n    num_centers = length(centers)\n    rbf_sys = RBFSum(kernels, w, num_vars, num_centers, num_outputs; static_arrays)\n\n    # vector output? (dismiss user choice if labels are vectors)\n    vec_output = num_outputs == 1 ? vector_output : true\n\n    return RBFModel{vec_output}( rbf_sys, poly_sys, num_vars, num_centers, num_outputs )\nend\n\n### Special Constructors","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"We offer some specialized models (that simply wrap the main type).","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"struct RBFInterpolationModel\n    model :: RBFModel\nend\n(mod :: RBFInterpolationModel)(args...) = mod.model(args...)\n@forward RBFInterpolationModel.model grad, jac, jacT, auto_grad, auto_jac","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"The constructor is a tiny bit simpler and additional checks take place:","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"\"\"\"\n    RBFInterpolationModel(features, labels, φ, poly_deg; kwargs… )\n\nBuild a model interpolating the feature-label pairs.\nDoes not accept `center` keyword argument.\n\"\"\"\nfunction RBFInterpolationModel(\n        features :: AnyVec{ <:NumberOrVector },\n        labels :: AnyVec{ <:NumberOrVector },\n        φ :: Union{RadialFunction,AnyVec{<:RadialFunction}} = Multiquadric(),\n        poly_deg :: Int = 1;\n        vector_output :: Bool = true,\n        static_arrays :: Bool = true\n    )\n    @assert length(features) == length(labels) \"Provide as many features as labels!\"\n    mod = RBFModel(features, labels, φ, poly_deg; vector_output, static_arrays)\n    return RBFInterpolationModel( mod )\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"We want to provide a convenient alternative constructor for interpolation models so that the radial function can be defined by passing a Symbol or String.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"const SymbolToRadialConstructor = NamedTuple((\n    :gaussian => Gaussian,\n    :multiquadric => Multiquadric,\n    :inv_multiquadric => InverseMultiquadric,\n    :cubic => Cubic,\n    :thin_plate_spline => ThinPlateSpline\n))\n\nfunction RBFInterpolationModel(\n        features :: AnyVec{ <:NumberOrVector },\n        labels :: AnyVec{ <:NumberOrVector },\n        φ_symb :: Union{Symbol, String},\n        φ_args :: Union{Nothing, Tuple} = nothing,\n        poly_deg :: Int = 1; kwargs...\n    )\n    # which radial function to use?\n    radial_symb = Symbol( lowercase( string( φ_symb ) ) )\n    if !(radial_symb ∈ keys(SymbolToRadialConstructor))\n        @warn \"Radial Funtion $(radial_symb) not known, using Gaussian.\"\n        radial_symb = :gaussian\n    end\n\n    constructor = SymbolToRadialConstructor[radial_symb]\n    if φ_args isa Tuple\n        φ = constructor( φ_args... )\n    else\n        φ = constructor()\n    end\n\n    RBFInterpolationModel( features, labels, φ, poly_deg; kwargs... )\nend","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"[wild_diss]: “Derivative-Free Optimization Algorithms For Computationally Expensive Functions”, Wild, 2009.","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"[wendland]: “Scattered Data Approximation”, Wendland","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"","category":"page"},{"location":"RBFModels/","page":"Main Module","title":"Main Module","text":"This page was generated using Literate.jl.","category":"page"},{"location":"README/","page":"Readme","title":"Readme","text":"EditURL = \"https://github.com/manuelbb-upb/RBFModels.jl/blob/master/test/README.jl\"","category":"page"},{"location":"README/#RBFModels","page":"Readme","title":"RBFModels","text":"","category":"section"},{"location":"README/","page":"Readme","title":"Readme","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage)","category":"page"},{"location":"README/#Description","page":"Readme","title":"Description","text":"","category":"section"},{"location":"README/","page":"Readme","title":"Readme","text":"This package provides Radial Basis Function (RBF) models with polynomial tails. RBF models are a special case of kernel machines can interpolate high-dimensional and nonlinear data.","category":"page"},{"location":"README/#Usage-Examples","page":"Readme","title":"Usage Examples","text":"","category":"section"},{"location":"README/","page":"Readme","title":"Readme","text":"First load the RBFModels package.","category":"page"},{"location":"README/","page":"Readme","title":"Readme","text":"using RBFModels","category":"page"},{"location":"README/","page":"Readme","title":"Readme","text":"We also use Test to validate the results and BenchmarkTools for comparisons.","category":"page"},{"location":"README/","page":"Readme","title":"Readme","text":"using Test\nusing BenchmarkTools","category":"page"},{"location":"README/#Interpolating-RBF-Model","page":"Readme","title":"Interpolating RBF Model","text":"","category":"section"},{"location":"README/#One-dimensional-data","page":"Readme","title":"One dimensional data","text":"","category":"section"},{"location":"README/","page":"Readme","title":"Readme","text":"The main type RBFModel uses vectors internally, but we can easily interpolate 1-dimensional data. Assume, e.g., we want to interpolate fℝ  ℝ f(x) = x^2:","category":"page"},{"location":"README/","page":"Readme","title":"Readme","text":"f = x -> x^2","category":"page"},{"location":"README/","page":"Readme","title":"Readme","text":"Define 5 training sites X and evaluate to get Y","category":"page"},{"location":"README/","page":"Readme","title":"Readme","text":"X = collect( LinRange(-4,4,5) )\nY = f.(X)","category":"page"},{"location":"README/","page":"Readme","title":"Readme","text":"Initialize the RadialFunction to use for the RBF model:","category":"page"},{"location":"README/","page":"Readme","title":"Readme","text":"φ = Multiquadric()","category":"page"},{"location":"README/","page":"Readme","title":"Readme","text":"Construct an interpolating model with linear polynomial tail:","category":"page"},{"location":"README/","page":"Readme","title":"Readme","text":"rbf = RBFModel( X, Y, φ, 1)","category":"page"},{"location":"README/","page":"Readme","title":"Readme","text":"We can evaluate rbf at the data points; By default, vectors are returned and for small dimensions StaticArrays are used. The results will be SVectors or SizedVectors","category":"page"},{"location":"README/","page":"Readme","title":"Readme","text":"Z = rbf.(X)\n@test Z isa Vector{<:RBFModels.StatVec}\n@test length(Z[1]) == 1","category":"page"},{"location":"README/","page":"Readme","title":"Readme","text":"The results should be close to the data labels Y.","category":"page"},{"location":"README/","page":"Readme","title":"Readme","text":"@test all( isapprox(Z[i][1], Y[i]; atol = 1e-10) for i = 1 : length(Z) )","category":"page"},{"location":"README/","page":"Readme","title":"Readme","text":"X contains Floats, but we can pass them to rbf. Usually you have feature vectors and they are always supported:","category":"page"},{"location":"README/","page":"Readme","title":"Readme","text":"@test rbf( [ X[1], ] ) == Z[1]","category":"page"},{"location":"README/","page":"Readme","title":"Readme","text":"For 1 dimensional labels we can actually disable the vector output:","category":"page"},{"location":"README/","page":"Readme","title":"Readme","text":"rbf_scalar = RBFInterpolationModel( X, Y, φ, 1; vector_output = false)\nZ_scalar = rbf_scalar.( X )\n@test Z_scalar isa Vector{Float64}\n@test all( Z_scalar[i] == Z[i][1] for i = 1 : length(Z) )","category":"page"},{"location":"README/","page":"Readme","title":"Readme","text":"Also, the StaticArrays can be disabled:","category":"page"},{"location":"README/","page":"Readme","title":"Readme","text":"rbf_vec = RBFInterpolationModel( X, Y, φ, 1; static_arrays = false)\nZ_vec = rbf_vec.(X)\n@test Z_vec isa Vector{Vector{Float64}}","category":"page"},{"location":"README/","page":"Readme","title":"Readme","text":"Whether StaticArrays are used and if vectors are returned is indicated by the type flags:","category":"page"},{"location":"README/","page":"Readme","title":"Readme","text":"@test rbf isa RBFModel{true, true}          # SVectors and vector output\n@test rbf_scalar isa RBFModel{true, false}  # SVectors and scalar output\n@test rbf_vec isa RBFModel{false, true}     # Vectors and vector output","category":"page"},{"location":"README/","page":"Readme","title":"Readme","text":"The data precision of the training data is preserved when evaluating.","category":"page"},{"location":"README/","page":"Readme","title":"Readme","text":"X_f0 = Float32.(X)\nY_f0 = f.(X_f0)\nrbf_f0 = RBFInterpolationModel( X_f0, Y_f0, φ, 1; static_arrays = false )\n@test rbf_f0.(X_f0) isa Vector{Vector{Float32}}","category":"page"},{"location":"README/","page":"Readme","title":"Readme","text":"Benchmarks for the small 1in1out data set. Construction:","category":"page"},{"location":"README/","page":"Readme","title":"Readme","text":"creation_times = [\n    median(@benchmark( RBFInterpolationModel( X, Y, φ, 1))),\n    median(@benchmark( RBFInterpolationModel( X, Y, φ, 1; vector_output = false))),\n    median(@benchmark( RBFInterpolationModel( X, Y, φ, 1; static_arrays = false))),\n    median(@benchmark( RBFInterpolationModel( X_f0, Y_f0, φ, 1)))\n]","category":"page"},{"location":"README/","page":"Readme","title":"Readme","text":"Evaluation:","category":"page"},{"location":"README/","page":"Readme","title":"Readme","text":"eval_times = [\n    median( @benchmark( rbf.(X) ) ),\n    median( @benchmark( rbf_scalar.(X) ) ),\n    median( @benchmark( rbf_vec.(X) ) ),\n    median( @benchmark( rbf_f0.(X_f0) ) )\n]","category":"page"},{"location":"README/","page":"Readme","title":"Readme","text":"","category":"page"},{"location":"README/","page":"Readme","title":"Readme","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = RBFModels","category":"page"},{"location":"#RBFModels","page":"Home","title":"RBFModels","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [RBFModels]","category":"page"},{"location":"#RBFModels.AnyVec-Tuple{Union{Vector{var\"#s8\"}, Union{StaticArrays.SVector{I, var\"#s8\"}, StaticArrays.SizedVector{I, var\"#s8\", V}} where {I, V}} where var\"#s8\"<:Real}","page":"Home","title":"RBFModels.AnyVec","text":"Evaluate x   k₁(x)  k_N_c(x) at x.\n\n\n\n\n\n","category":"method"},{"location":"#RBFModels.Cubic","page":"Home","title":"RBFModels.Cubic","text":"Cubic( β = 3 ) <: RadialFunction\n\nA RadialFunction with \n\n    φ(ρ) = (-1)^ lceil β rceil 2  ρ^β\n\n\n\n\n\n","category":"type"},{"location":"#RBFModels.Gaussian","page":"Home","title":"RBFModels.Gaussian","text":"Gaussian( α = 1 ) <: RadialFunction\n\nA RadialFunction with \n\n    φ(ρ) = exp( - (α ρ)^2 )\n\n\n\n\n\n","category":"type"},{"location":"#RBFModels.InverseMultiquadric","page":"Home","title":"RBFModels.InverseMultiquadric","text":"InverseMultiquadric( α = 1, β = 1//2 ) <: RadialFunction\n\nA RadialFunction with \n\n    φ(ρ) = ( 1 + (αρ)^2 )^-β\n\n\n\n\n\n","category":"type"},{"location":"#RBFModels.Multiquadric","page":"Home","title":"RBFModels.Multiquadric","text":"Multiquadric( α = 1, β = 1//2 ) <: RadialFunction\n\nA RadialFunction with \n\n    φ(ρ) = (-1)^ lceil β rceil  ( 1 + (αρ)^2 )^β\n\n\n\n\n\n","category":"type"},{"location":"#RBFModels.RBFInterpolationModel","page":"Home","title":"RBFModels.RBFInterpolationModel","text":"RBFInterpolationModel(features, labels, φ, poly_deg; kwargs… )\n\nBuild a model interpolating the feature-label pairs. Does not accept center keyword argument.\n\n\n\n\n\n","category":"type"},{"location":"#RBFModels.RBFModel","page":"Home","title":"RBFModels.RBFModel","text":"RBFModel{V}\n\nV is true by default. It can be set to false only if the number  of outputs is 1. Then scalars are returned.\n\n\n\n\n\n","category":"type"},{"location":"#RBFModels.RBFModel-2","page":"Home","title":"RBFModels.RBFModel","text":"Evaluate model mod :: RBFModel at vector x.\n\n\n\n\n\n","category":"type"},{"location":"#RBFModels.RBFModel-3","page":"Home","title":"RBFModels.RBFModel","text":"RBFModel( features, labels, φ = Multiquadric(), poly_deg = 1; kwargs ... )\n\nConstruct a RBFModel from the feature vectors in features and  the corresponding labels in lables, where φ is a RadialFunction or a vector of  RadialFunctions.\n\nScalar data can be used, it is transformed internally. \n\nStaticArrays can be used, e.g., features :: Vector{<:SVector}.  Providing SVectors only might speed up the construction.\n\nIf the degree of the polynomial tail, poly_deg, is too small it will be set to cpd_order(φ)-1.\n\nIf the RBF centers do not equal the the features, you can use the keyword argument centers to pass a list of centers. If φ is a vector, then the length of centers and φ must be equal and  centers[i] will be used in conjunction with φ[i] to build a ShiftedKernel. \n\nIf features has 1D data, the output of the model will be a 1D-vector. If it should be a scalar instead, set the keyword argument vector_output to false.\n\n\n\n\n\n","category":"type"},{"location":"#RBFModels.RBFModel-Tuple{Union{Vector{var\"#s10\"}, Union{StaticArrays.SVector{I, var\"#s10\"}, StaticArrays.SizedVector{I, var\"#s10\", V}} where {I, V}} where var\"#s10\"<:Real, Int64}","page":"Home","title":"RBFModels.RBFModel","text":"Evaluate scalar output ℓ of model mod at vector x.\n\n\n\n\n\n","category":"method"},{"location":"#RBFModels.RBFSum-Tuple{Union{Vector{var\"#s10\"}, Union{StaticArrays.SVector{I, var\"#s10\"}, StaticArrays.SizedVector{I, var\"#s10\", V}} where {I, V}} where var\"#s10\"<:Real, Int64}","page":"Home","title":"RBFModels.RBFSum","text":"Evaluate output ℓ of RBF sum rbf::RBFSum\n\n\n\n\n\n","category":"method"},{"location":"#RBFModels.RBFSum-Tuple{Union{Vector{var\"#s10\"}, Union{StaticArrays.SVector{I, var\"#s10\"}, StaticArrays.SizedVector{I, var\"#s10\", V}} where {I, V}} where var\"#s10\"<:Real}","page":"Home","title":"RBFModels.RBFSum","text":"Evaluate rbf::RBFSum at x.\n\n\n\n\n\n","category":"method"},{"location":"#RBFModels.ShiftedKernel-Tuple{Union{Vector{var\"#s9\"}, Union{StaticArrays.SVector{I, var\"#s9\"}, StaticArrays.SizedVector{I, var\"#s9\", V}} where {I, V}} where var\"#s9\"<:Real}","page":"Home","title":"RBFModels.ShiftedKernel","text":"Evaluate kernel k at x - k.c.\n\n\n\n\n\n","category":"method"},{"location":"#RBFModels.ThinPlateSpline","page":"Home","title":"RBFModels.ThinPlateSpline","text":"ThinPlateSpline( k = 2 ) <: RadialFunction\n\nA RadialFunction with \n\n    φ(ρ) = (-1)^k+1 ρ^2k log(ρ)\n\n\n\n\n\n","category":"type"},{"location":"#RBFModels.auto_grad","page":"Home","title":"RBFModels.auto_grad","text":"Return gradient of output ℓ of model rbf at point x (using Zygote).\n\n\n\n\n\n","category":"function"},{"location":"#RBFModels.auto_jac-Tuple{RBFModel, Union{Vector{var\"#s27\"}, Union{StaticArrays.SVector{I, var\"#s27\"}, StaticArrays.SizedVector{I, var\"#s27\", V}} where {I, V}} where var\"#s27\"<:Real}","page":"Home","title":"RBFModels.auto_jac","text":"Return the jacobian of rbf at x (using Zygote).\n\n\n\n\n\n","category":"method"},{"location":"#RBFModels.canonical_basis-Tuple{Int64, Int64}","page":"Home","title":"RBFModels.canonical_basis","text":"canonical_basis( n:: Int, d :: Int )\n\nReturn the canonical basis of the space of n-variate  polynomials of degree at most d.\n\n\n\n\n\n","category":"method"},{"location":"#RBFModels.coefficients-Tuple{Union{Vector{var\"#s28\"}, Union{StaticArrays.SVector{I, var\"#s28\"}, StaticArrays.SizedVector{I, var\"#s28\", V}} where {I, V}} where var\"#s28\"<:(Union{Vector{var\"#s27\"}, Union{StaticArrays.SVector{I, var\"#s27\"}, StaticArrays.SizedVector{I, var\"#s27\", V}} where {I, V}} where var\"#s27\"), Union{Vector{var\"#s28\"}, Union{StaticArrays.SVector{I, var\"#s28\"}, StaticArrays.SizedVector{I, var\"#s28\", V}} where {I, V}} where var\"#s28\"<:(Union{Vector{var\"#s27\"}, Union{StaticArrays.SVector{I, var\"#s27\"}, StaticArrays.SizedVector{I, var\"#s27\", V}} where {I, V}} where var\"#s27\"), Union{Union{StaticArrays.SVector{I, RBFModels.ShiftedKernel}, StaticArrays.SizedVector{I, RBFModels.ShiftedKernel, V}} where {I, V}, Vector{RBFModels.ShiftedKernel}}, Vector{var\"#s27\"} where var\"#s27\"<:DynamicPolynomials.Polynomial}","page":"Home","title":"RBFModels.coefficients","text":"coefficients(sites, values, kernels, rad_funcs, polys )\n\nReturn the coefficient matrices w and λ for an rbf model  r(x) = Σ_i=1^N wᵢ φ(x - x^i) + Σ_j=1^M λᵢ pᵢ(x), where N is the length of rad_funcs (and centers) and M is the length of polys.\n\nThe arguments are \n\nan array of data sites sites with vector entries from ℝ^n.\nan array of data values values with vector entries from ℝ^k.\nan array of ShiftedKernels.\nan array polys of polynomial basis functions.\n\n\n\n\n\n","category":"method"},{"location":"#RBFModels.eval_and_auto_grad","page":"Home","title":"RBFModels.eval_and_auto_grad","text":"Evaluate output ℓ of the model and return the gradient.\n\n\n\n\n\n","category":"function"},{"location":"#RBFModels.eval_and_auto_jac-Tuple{RBFModel, Union{Vector{var\"#s11\"}, Union{StaticArrays.SVector{I, var\"#s11\"}, StaticArrays.SizedVector{I, var\"#s11\", V}} where {I, V}} where var\"#s11\"<:Real}","page":"Home","title":"RBFModels.eval_and_auto_jac","text":"Evaluate the model and return the jacobian at the same time.\n\n\n\n\n\n","category":"method"},{"location":"#RBFModels.eval_at_dist-Tuple{RBFModels.ShiftedKernel, Real}","page":"Home","title":"RBFModels.eval_at_dist","text":"Evaluate k.φ for distance ρ where ρ should equal x - k.c for the argument x.\n\n\n\n\n\n","category":"method"},{"location":"#RBFModels.eval_at_dist-Tuple{Union{Union{StaticArrays.SVector{I, RBFModels.ShiftedKernel}, StaticArrays.SizedVector{I, RBFModels.ShiftedKernel, V}} where {I, V}, Vector{RBFModels.ShiftedKernel}}, Vector{var\"#s11\"} where var\"#s11\"<:Real}","page":"Home","title":"RBFModels.eval_at_dist","text":"Evaluate x   k₁(x)  k_N_c(x), provided the distances  ρ_1(x)  ρ_N_c(x) .\n\n\n\n\n\n","category":"method"},{"location":"#RBFModels.make_kernels-Tuple{RBFModels.RadialFunction, Union{Vector{var\"#s28\"}, Union{StaticArrays.SVector{I, var\"#s28\"}, StaticArrays.SizedVector{I, var\"#s28\", V}} where {I, V}} where var\"#s28\"<:(Union{Vector{var\"#s27\"}, Union{StaticArrays.SVector{I, var\"#s27\"}, StaticArrays.SizedVector{I, var\"#s27\", V}} where {I, V}} where var\"#s27\")}","page":"Home","title":"RBFModels.make_kernels","text":"Return array of ShiftedKernels based function φ with centers from centers.\n\n\n\n\n\n","category":"method"},{"location":"#RBFModels.make_kernels-Tuple{Union{Vector{var\"#s27\"}, Union{StaticArrays.SVector{I, var\"#s27\"}, StaticArrays.SizedVector{I, var\"#s27\", V}} where {I, V}} where var\"#s27\"<:RBFModels.RadialFunction, Union{Vector{var\"#s28\"}, Union{StaticArrays.SVector{I, var\"#s28\"}, StaticArrays.SizedVector{I, var\"#s28\", V}} where {I, V}} where var\"#s28\"<:(Union{Vector{var\"#s27\"}, Union{StaticArrays.SVector{I, var\"#s27\"}, StaticArrays.SizedVector{I, var\"#s27\", V}} where {I, V}} where var\"#s27\")}","page":"Home","title":"RBFModels.make_kernels","text":"Return array of ShiftedKernels based functions in φ_arr with centers from centers.\n\n\n\n\n\n","category":"method"},{"location":"#RBFModels.non_negative_solutions-Tuple{Int64, Int64}","page":"Home","title":"RBFModels.non_negative_solutions","text":"non_negative_solutions( d :: Int, n :: Int)\n\nReturn array of solution vectors x_1  x_n to the equation x_1 +  + x_n = d where the variables are non-negative integers.\n\n\n\n\n\n","category":"method"}]
}
